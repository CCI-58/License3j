# License3j ライセンスファイル出力ガイド

## 目次
1. [概要](#概要)
2. [ライセンスファイルの出力形式](#ライセンスファイルの出力形式)
3. [方法1: Javaコードでライセンスファイルを出力](#方法1-javaコードでライセンスファイルを出力)
4. [方法2: REPLツールでライセンスファイルを出力](#方法2-replツールでライセンスファイルを出力)
5. [方法3: ライセンスオブジェクトを文字列として出力](#方法3-ライセンスオブジェクトを文字列として出力)
6. [実践例](#実践例)
7. [トラブルシューティング](#トラブルシューティング)

---

## 概要

License3jは、Javaアプリケーション向けのライセンス管理ライブラリです。このガイドでは、ライセンスファイルを作成し、様々な形式で出力する方法を説明します。

### ライセンスとは

License3jにおけるライセンスは、**フィーチャー（Feature）**の集合です。各フィーチャーには以下の要素があります：

- **名前（name）**: 任意の文字列
- **型（type）**: BINARY, STRING, INT, DATE, UUID など12種類
- **値（value）**: 型に応じた値

### 主な用途

- ソフトウェアの有効期限管理
- ユーザー数制限
- 機能の有効/無効制御
- ハードウェアバインディング

---

## ライセンスファイルの出力形式

License3jは3つの出力形式をサポートしています：

### 1. BINARY形式（バイナリ）

**特徴:**
- 最もコンパクトな形式
- ファイルサイズが最小
- 人間が読めない
- 推奨される形式

**用途:**
- 本番環境でのライセンス配布
- ファイルサイズを最小化したい場合

**ファイル拡張子:** `.bin`

**マジックバイト:** `0x21CE4E5E` (LICENSEを表す)

### 2. BASE64形式

**特徴:**
- BINARYをBase64エンコードしたもの
- テキストファイルとして扱える
- メールで送信可能
- BINARYより約33%大きい

**用途:**
- メール経由でのライセンス配布
- テキストベースの設定ファイルへの埋め込み

**ファイル拡張子:** `.b64` または `.txt`

### 3. STRING形式（テキスト）

**特徴:**
- 人間が読める形式
- テキストエディタで編集可能
- UTF-8エンコード
- 最も大きいファイルサイズ

**用途:**
- 開発・デバッグ時
- ライセンス内容の確認
- 手動でのライセンス編集

**ファイル拡張子:** `.txt`

**フォーマット例:**
```
owner=TestUser
expiryDate:DATE=2025-12-31
maxUsers:INT=100
licenseId:UUID=550e8400-e29b-41d4-a716-446655440000
```

---

## 方法1: Javaコードでライセンスファイルを出力

### 必要な依存関係

`pom.xml`に以下を追加：

```xml
<dependency>
    <groupId>com.javax0.license3j</groupId>
    <artifactId>license3j</artifactId>
    <version>3.3.0</version>
</dependency>
```

### 基本的な手順

#### ステップ1: ライセンスオブジェクトの作成

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import java.util.Date;
import java.util.Calendar;

// 新しいライセンスを作成
License license = new License();

// フィーチャーを追加
license.add(Feature.Create.stringFeature("owner", "株式会社サンプル"));
license.add(Feature.Create.intFeature("maxUsers", 100));

// 有効期限を設定（1年後）
Calendar cal = Calendar.getInstance();
cal.add(Calendar.YEAR, 1);
license.setExpiry(cal.getTime());

// ライセンスIDを生成
license.setLicenseId();
```

#### ステップ2: ライセンスに署名（オプションだが推奨）

```java
import javax0.license3j.crypto.LicenseKeyPair;
import java.security.PrivateKey;

// 秘密鍵を読み込む（事前に生成済みの鍵を使用）
byte[] privateKeyBytes = {/* 秘密鍵のバイト配列 */};
LicenseKeyPair keyPair = LicenseKeyPair.Create.from(privateKeyBytes, java.lang.reflect.Modifier.PRIVATE);
PrivateKey privateKey = keyPair.getPair().getPrivate();

// ライセンスに署名
license.sign(privateKey, "SHA-512");
```

#### ステップ3: ライセンスファイルの出力

##### BINARY形式で出力

```java
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;
import java.io.IOException;

try (LicenseWriter writer = new LicenseWriter("license.bin")) {
    writer.write(license, IOFormat.BINARY);
} catch (IOException e) {
    System.err.println("ライセンスファイルの書き込みに失敗しました: " + e.getMessage());
}
```

##### BASE64形式で出力

```java
try (LicenseWriter writer = new LicenseWriter("license.b64")) {
    writer.write(license, IOFormat.BASE64);
} catch (IOException e) {
    System.err.println("ライセンスファイルの書き込みに失敗しました: " + e.getMessage());
}
```

##### STRING形式で出力

```java
try (LicenseWriter writer = new LicenseWriter("license.txt")) {
    writer.write(license, IOFormat.STRING);
} catch (IOException e) {
    System.err.println("ライセンスファイルの書き込みに失敗しました: " + e.getMessage());
}
```

### 完全なサンプルコード

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import javax0.license3j.crypto.LicenseKeyPair;
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;

import java.util.Calendar;

public class LicenseGenerator {
    
    public static void main(String[] args) {
        try {
            // 1. ライセンスを作成
            License license = new License();
            
            // 2. フィーチャーを追加
            license.add(Feature.Create.stringFeature("owner", "株式会社サンプル"));
            license.add(Feature.Create.stringFeature("product", "Sample Product"));
            license.add(Feature.Create.intFeature("maxUsers", 100));
            
            // 3. 有効期限を設定（1年後）
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.YEAR, 1);
            license.setExpiry(cal.getTime());
            
            // 4. ライセンスIDを生成
            license.setLicenseId();
            
            // 5. 秘密鍵で署名（事前に生成した鍵を使用）
            byte[] privateKeyBytes = loadPrivateKey(); // 実装が必要
            LicenseKeyPair keyPair = LicenseKeyPair.Create.from(
                privateKeyBytes, 
                java.lang.reflect.Modifier.PRIVATE
            );
            license.sign(keyPair.getPair().getPrivate(), "SHA-512");
            
            // 6. 3つの形式で出力
            try (LicenseWriter writer = new LicenseWriter("license.bin")) {
                writer.write(license, IOFormat.BINARY);
                System.out.println("BINARY形式で出力しました: license.bin");
            }
            
            try (LicenseWriter writer = new LicenseWriter("license.b64")) {
                writer.write(license, IOFormat.BASE64);
                System.out.println("BASE64形式で出力しました: license.b64");
            }
            
            try (LicenseWriter writer = new LicenseWriter("license.txt")) {
                writer.write(license, IOFormat.STRING);
                System.out.println("STRING形式で出力しました: license.txt");
            }
            
        } catch (Exception e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static byte[] loadPrivateKey() {
        // 秘密鍵を読み込む実装
        // ファイルから読み込むか、ハードコードされた配列を返す
        return new byte[]{/* 秘密鍵のバイト */};
    }
}
```

---

## 方法2: REPLツールでライセンスファイルを出力

REPLツールは、コマンドラインからインタラクティブにライセンスを作成・管理できるツールです。

### REPLツールの入手

REPLツールは別プロジェクトとして提供されています：
https://github.com/verhas/license3jrepl

JARファイルをダウンロードして使用します。

### REPLツールの起動

```bash
java -jar license3jrepl.jar
```

起動すると以下のプロンプトが表示されます：

```
License3j REPL
CDW is /current/working/directory/.
help for help
L3j> $
```

### 基本的な使い方

#### ステップ1: 鍵ペアの生成

```
L3j> $ generateKeys algorithm=RSA size=2048 format=BINARY public=public.key private=private.key
```

**パラメータ説明:**
- `algorithm=RSA`: 暗号化アルゴリズム（RSA推奨）
- `size=2048`: 鍵のサイズ（2048ビット以上推奨）
- `format=BINARY`: 出力形式（BINARYまたはBASE64）
- `public=public.key`: 公開鍵の保存先ファイル名
- `private=private.key`: 秘密鍵の保存先ファイル名

#### ステップ2: 新しいライセンスの作成

```
L3j> $ newLicense
```

#### ステップ3: フィーチャーの追加

```
L3j> $ feature owner:STRING=株式会社サンプル
L3j> $ feature product:STRING=Sample Product
L3j> $ feature maxUsers:INT=100
L3j> $ feature expiryDate:DATE=2025-12-31
```

**フィーチャーの形式:**
```
feature 名前:型=値
```

**型の省略:**
STRING型の場合は型を省略できます：
```
L3j> $ feature owner=株式会社サンプル
```

**サポートされる型:**
- `STRING`: 文字列
- `INT`: 整数
- `LONG`: 長整数
- `FLOAT`: 浮動小数点数
- `DOUBLE`: 倍精度浮動小数点数
- `DATE`: 日付（形式: YYYY-MM-DD または YYYY-MM-DD HH:MM:SS）
- `UUID`: UUID
- `BINARY`: バイナリデータ（Base64エンコード）
- `BYTE`: バイト値
- `SHORT`: 短整数
- `BIGINTEGER`: 任意精度整数
- `BIGDECIMAL`: 任意精度小数

#### ステップ4: 秘密鍵の読み込み

```
L3j> $ loadPrivateKey format=BINARY keyFile=private.key
```

#### ステップ5: ライセンスに署名

```
L3j> $ sign digest=SHA-512
```

**digestオプション:**
- `SHA-512`: 最も推奨（デフォルト）
- `SHA-256`: 代替オプション
- `SHA-1`: 非推奨

#### ステップ6: ライセンスの保存

##### BINARY形式で保存

```
L3j> $ saveLicense format=BINARY license.bin
```

##### BASE64形式で保存

```
L3j> $ saveLicense format=BASE64 license.b64
```

##### STRING形式で保存

```
L3j> $ saveLicense format=TEXT license.txt
```

**注意:** REPLツールでは`TEXT`と表記しますが、Javaコードでは`STRING`です。

### 完全なREPLセッション例

```
$ java -jar license3jrepl.jar
License3j REPL
CDW is /home/user/licenses/.
help for help
L3j> $ generateKeys algorithm=RSA size=2048 format=BINARY public=public.key private=private.key
[INFO] Keys generated and saved

L3j> $ newLicense
[INFO] New license created

L3j> $ feature owner=株式会社サンプル
[INFO] Feature added

L3j> $ feature product=Sample Product
[INFO] Feature added

L3j> $ feature maxUsers:INT=100
[INFO] Feature added

L3j> $ feature expiryDate:DATE=2025-12-31
[INFO] Feature added

L3j> $ loadPrivateKey format=BINARY keyFile=private.key
[INFO] Private key loaded

L3j> $ sign digest=SHA-512
[INFO] License signed

L3j> $ saveLicense format=BINARY license.bin
[INFO] License saved to license.bin

L3j> $ saveLicense format=BASE64 license.b64
[INFO] License saved to license.b64

L3j> $ saveLicense format=TEXT license.txt
[INFO] License saved to license.txt

L3j> $ exit
```

### REPLツールの便利な機能

#### ライセンス内容の確認

```
L3j> $ dump
```

現在のライセンスの全フィーチャーを表示します。

#### 既存ライセンスの読み込み

```
L3j> $ licenseLoad format=BINARY license.bin
```

#### ライセンスの検証

```
L3j> $ loadPublicKey format=BINARY keyFile=public.key
L3j> $ verify
```

#### 公開鍵のJavaコード出力

```
L3j> $ dumpPublicKey
```

アプリケーションに埋め込むためのJavaコードを出力します：

```java
byte [] key = new byte[] {
(byte)0x30,(byte)0x81,(byte)0x9F,(byte)0x30,
(byte)0x0D,(byte)0x06,(byte)0x09,(byte)0x2A,
// ... 省略 ...
(byte)0x01,(byte)0x00,(byte)0x01
};
```

#### コマンドの省略形

REPLツールでは、コマンドを一意に識別できる最小限の文字数で省略できます：

- `generateKeys` → `gen` または `g`
- `newLicense` → `new` または `n`
- `feature` → `f`
- `sign` → `si`
- `saveLicense` → `save` または `s`

#### スクリプトファイルの実行

コマンドをファイルに保存して実行できます：

```
L3j> $ .myscript.txt
```

`.license3j`という名前のファイルが作業ディレクトリにある場合、起動時に自動実行されます。

#### シェルコマンドの実行

```
L3j> $ !ls -la
L3j> $ !dir
```

---

## 方法3: ライセンスオブジェクトを文字列として出力

ファイルに保存せず、文字列として取得する方法もあります。

### バイナリデータとして取得

```java
License license = new License();
// ... フィーチャーを追加 ...

// バイナリ形式のバイト配列を取得
byte[] binaryData = license.serialized();

// Base64エンコードされた文字列として取得
String base64String = java.util.Base64.getEncoder().encodeToString(binaryData);
System.out.println("Base64: " + base64String);
```

### テキスト形式として取得

```java
License license = new License();
// ... フィーチャーを追加 ...

// テキスト形式の文字列を取得
String textFormat = license.toString();
System.out.println(textFormat);
```

**出力例:**
```
expiryDate:DATE=2025-12-31 23:59:59.999
licenseId:UUID=550e8400-e29b-41d4-a716-446655440000
maxUsers:INT=100
owner=株式会社サンプル
product=Sample Product
```

### 文字列からライセンスを作成

```java
// テキスト形式の文字列からライセンスを作成
String licenseText = "owner=TestUser\nmaxUsers:INT=100\nexpiryDate:DATE=2025-12-31";
License license = License.Create.from(licenseText);

// バイナリデータからライセンスを作成
byte[] binaryData = {/* バイナリデータ */};
License license2 = License.Create.from(binaryData);
```

---

## 実践例

### 例1: 期限付きライセンスの作成

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;
import java.util.Calendar;

public class CreateTimeLimitedLicense {
    public static void main(String[] args) throws Exception {
        // ライセンスを作成
        License license = new License();
        
        // 顧客情報
        license.add(Feature.Create.stringFeature("customer", "株式会社ABC"));
        license.add(Feature.Create.stringFeature("email", "contact@abc.co.jp"));
        
        // 製品情報
        license.add(Feature.Create.stringFeature("product", "Enterprise Edition"));
        license.add(Feature.Create.stringFeature("version", "2.0"));
        
        // 有効期限を6ヶ月後に設定
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.MONTH, 6);
        license.setExpiry(cal.getTime());
        
        // ライセンスIDを生成
        license.setLicenseId();
        
        // BINARY形式で保存
        try (LicenseWriter writer = new LicenseWriter("enterprise_license.bin")) {
            writer.write(license, IOFormat.BINARY);
            System.out.println("ライセンスを作成しました: enterprise_license.bin");
            System.out.println("有効期限: " + cal.getTime());
        }
    }
}
```

### 例2: ユーザー数制限付きライセンス

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;

public class CreateUserLimitedLicense {
    public static void main(String[] args) throws Exception {
        License license = new License();
        
        // ユーザー制限
        license.add(Feature.Create.intFeature("maxUsers", 50));
        license.add(Feature.Create.intFeature("maxConcurrentUsers", 10));
        
        // 機能制限
        license.add(Feature.Create.booleanFeature("advancedReports", true));
        license.add(Feature.Create.booleanFeature("apiAccess", true));
        license.add(Feature.Create.booleanFeature("cloudBackup", false));
        
        // 顧客情報
        license.add(Feature.Create.stringFeature("company", "株式会社XYZ"));
        
        // ライセンスIDを生成
        license.setLicenseId();
        
        // STRING形式で保存（内容確認用）
        try (LicenseWriter writer = new LicenseWriter("user_limited_license.txt")) {
            writer.write(license, IOFormat.STRING);
            System.out.println("ライセンスを作成しました: user_limited_license.txt");
        }
    }
}
```

**注意:** `booleanFeature`は直接サポートされていないため、代わりに以下を使用：

```java
// trueの場合
license.add(Feature.Create.byteFeature("advancedReports", (byte)1));
// falseの場合
license.add(Feature.Create.byteFeature("cloudBackup", (byte)0));
```

### 例3: ハードウェアバインディング付きライセンス

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import javax0.license3j.HardwareBinder;
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;
import java.util.UUID;

public class CreateHardwareBoundLicense {
    public static void main(String[] args) throws Exception {
        // マシンUUIDを取得
        UUID machineId = new HardwareBinder()
            .allowed("eth.*")  // イーサネットインターフェースのみ許可
            .denied("docker.*")  // Dockerインターフェースを除外
            .getMachineId();
        
        // ライセンスを作成
        License license = new License();
        
        // ハードウェアIDを追加
        license.add(Feature.Create.uuidFeature("machineId", machineId));
        
        // 顧客情報
        license.add(Feature.Create.stringFeature("customer", "株式会社DEF"));
        
        // ライセンスIDを生成
        license.setLicenseId();
        
        // 保存
        try (LicenseWriter writer = new LicenseWriter("hardware_bound_license.bin")) {
            writer.write(license, IOFormat.BINARY);
            System.out.println("ハードウェアバインディング付きライセンスを作成しました");
            System.out.println("マシンID: " + machineId);
        }
    }
}
```

### 例4: 複数形式での一括出力

```java
import javax0.license3j.License;
import javax0.license3j.Feature;
import javax0.license3j.io.LicenseWriter;
import javax0.license3j.io.IOFormat;

public class ExportMultipleFormats {
    public static void main(String[] args) {
        try {
            // ライセンスを作成
            License license = createSampleLicense();
            
            // 3つの形式で出力
            String[] formats = {"bin", "b64", "txt"};
            IOFormat[] ioFormats = {IOFormat.BINARY, IOFormat.BASE64, IOFormat.STRING};
            
            for (int i = 0; i < formats.length; i++) {
                String filename = "license." + formats[i];
                try (LicenseWriter writer = new LicenseWriter(filename)) {
                    writer.write(license, ioFormats[i]);
                    System.out.println("✓ " + filename + " を作成しました");
                }
            }
            
            System.out.println("\n全ての形式で出力が完了しました！");
            
        } catch (Exception e) {
            System.err.println("エラー: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static License createSampleLicense() {
        License license = new License();
        license.add(Feature.Create.stringFeature("owner", "サンプル株式会社"));
        license.add(Feature.Create.stringFeature("product", "Sample Software"));
        license.add(Feature.Create.intFeature("maxUsers", 100));
        license.setLicenseId();
        return license;
    }
}
```

---

## トラブルシューティング

### よくある問題と解決方法

#### 問題1: ファイルが作成されない

**症状:**
```
java.io.FileNotFoundException: license.bin (Permission denied)
```

**解決方法:**
- 書き込み権限のあるディレクトリを指定する
- 絶対パスを使用する
```java
try (LicenseWriter writer = new LicenseWriter("/home/user/licenses/license.bin")) {
    writer.write(license, IOFormat.BINARY);
}
```

#### 問題2: 署名時のエラー

**症状:**
```
java.security.InvalidKeyException: Invalid key format
```

**解決方法:**
- 秘密鍵が正しく読み込まれているか確認
- 鍵のフォーマットが正しいか確認
```java
// 正しい読み込み方法
LicenseKeyPair keyPair = LicenseKeyPair.Create.from(
    privateKeyBytes, 
    java.lang.reflect.Modifier.PRIVATE
);
```

#### 問題3: 日付フィーチャーのパースエラー

**症状:**
```
java.text.ParseException: Unparseable date
```

**解決方法:**
- 日付形式を確認する（YYYY-MM-DD または YYYY-MM-DD HH:MM:SS）
```java
// 正しい形式
license.add(Feature.Create.dateFeature("expiryDate", 
    new SimpleDateFormat("yyyy-MM-dd").parse("2025-12-31")));
```

#### 問題4: REPLツールで日本語が文字化けする

**解決方法:**
- JVMの文字エンコーディングを指定して起動
```bash
java -Dfile.encoding=UTF-8 -jar license3jrepl.jar
```

#### 問題5: ライセンスファイルが大きすぎる

**解決方法:**
- BINARY形式を使用する（最もコンパクト）
- 不要なフィーチャーを削除する
- BINARYデータ型のフィーチャーを最小限にする

#### 問題6: マルチバイト文字列の扱い

**症状:**
日本語などのマルチバイト文字が正しく保存されない

**解決方法:**
- STRING形式はUTF-8で保存されるため、通常は問題なし
- ファイル読み込み時にUTF-8を指定
```java
// 読み込み時
try (LicenseReader reader = new LicenseReader("license.txt")) {
    License license = reader.read(IOFormat.STRING);
}
```

### デバッグのヒント

#### ライセンス内容の確認

```java
// ライセンスの全フィーチャーを表示
License license = /* ... */;
System.out.println(license.toString());

// 個別のフィーチャーを確認
Feature feature = license.get("owner");
if (feature != null) {
    System.out.println("Owner: " + feature.getString());
}
```

#### バイナリデータの16進ダンプ

```java
byte[] data = license.serialized();
for (int i = 0; i < Math.min(data.length, 100); i++) {
    System.out.printf("%02X ", data[i]);
    if ((i + 1) % 16 == 0) System.out.println();
}
```

#### ライセンスのフィンガープリント確認

```java
UUID fingerprint = license.fingerprint();
System.out.println("License fingerprint: " + fingerprint);
```

---

## まとめ

License3jでライセンスファイルを出力する方法は主に3つあります：

1. **Javaコード**: プログラムから自動的にライセンスを生成・出力
2. **REPLツール**: コマンドラインから対話的にライセンスを作成
3. **文字列変換**: ファイルに保存せず、メモリ上で処理

### 推奨される使い方

- **本番環境**: BINARY形式で署名付きライセンスを配布
- **開発環境**: STRING形式で内容を確認しながら開発
- **メール配布**: BASE64形式を使用
- **自動生成**: Javaコードで大量のライセンスを生成
- **手動作成**: REPLツールで個別にライセンスを作成

### セキュリティのベストプラクティス

1. **秘密鍵の管理**: 秘密鍵は厳重に管理し、バージョン管理システムにコミットしない
2. **署名の使用**: 本番環境では必ず署名付きライセンスを使用
3. **公開鍵の埋め込み**: アプリケーションに公開鍵をハードコード
4. **有効期限の設定**: 適切な有効期限を設定
5. **ハードウェアバインディング**: 必要に応じてマシンIDを含める

### 参考リンク

- License3j GitHub: https://github.com/verhas/License3j
- License3j REPL: https://github.com/verhas/license3jrepl
- JavaDoc: https://verhas.github.io/License3j/

---

**作成日**: 2025年11月13日  
**License3jバージョン**: 3.3.0
