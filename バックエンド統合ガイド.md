# License3j バックエンド統合ガイド

## 目次
1. [概要](#概要)
2. [基本的なライセンス検証フロー](#基本的なライセンス検証フロー)
3. [ライセンスファイルの読み込み](#ライセンスファイルの読み込み)
4. [署名の検証](#署名の検証)
5. [フィーチャーの取得と検証](#フィーチャーの取得と検証)
6. [有効期限のチェック](#有効期限のチェック)
7. [ハードウェアバインディング](#ハードウェアバインディング)
8. [実装パターン](#実装パターン)
9. [エラーハンドリング](#エラーハンドリング)
10. [セキュリティのベストプラクティス](#セキュリティのベストプラクティス)
11. [パフォーマンス最適化](#パフォーマンス最適化)

---

## 概要

License3jをバックエンドアプリケーションに統合することで、ソフトウェアライセンスの検証と管理を実現できます。このガイドでは、バックエンド側でLicense3jがどのように機能するか、そして実際の実装方法を詳しく説明します。

### License3jの役割

バックエンドにおけるLicense3jの主な役割：

1. **ライセンスファイルの読み込み**: 様々な形式（BINARY、BASE64、STRING）のライセンスファイルを読み込む
2. **署名の検証**: 公開鍵を使用してライセンスの真正性を確認
3. **フィーチャーの取得**: ライセンスに含まれる各種設定値を取得
4. **有効期限の確認**: ライセンスの期限切れをチェック
5. **ハードウェアバインディング**: 特定のマシンへのライセンス紐付け

### アーキテクチャ概要

```
[ライセンスファイル] 
    ↓
[LicenseReader] → ライセンスファイルを読み込み
    ↓
[License オブジェクト]
    ↓
[署名検証] → 公開鍵で真正性を確認
    ↓
[フィーチャー取得] → 設定値を取得
    ↓
[ビジネスロジック] → ライセンス情報に基づいて機能を制御
```

---

## 基本的なライセンス検証フロー

### 標準的な検証フロー

```java
import javax0.license3j.License;
import javax0.license3j.io.LicenseReader;
import javax0.license3j.io.IOFormat;
import java.io.IOException;

public class LicenseValidator {
    
    // 公開鍵をアプリケーションに埋め込む（推奨）
    private static final byte[] PUBLIC_KEY = {
        (byte)0x52, (byte)0x53, (byte)0x41, (byte)0x00,
        // ... 公開鍵のバイト配列 ...
    };
    
    public boolean validateLicense(String licenseFilePath) {
        try {
            // 1. ライセンスファイルを読み込む
            License license = readLicense(licenseFilePath);
            
            // 2. 署名を検証する
            if (!license.isOK(PUBLIC_KEY)) {
                System.err.println("ライセンスの署名が無効です");
                return false;
            }
            
            // 3. 有効期限をチェックする
            if (license.isExpired()) {
                System.err.println("ライセンスの有効期限が切れています");
                return false;
            }
            
            // 4. その他のフィーチャーを検証する
            if (!validateFeatures(license)) {
                System.err.println("ライセンスのフィーチャーが無効です");
                return false;
            }
            
            return true;
            
        } catch (Exception e) {
            System.err.println("ライセンスの検証中にエラーが発生しました: " + e.getMessage());
            return false;
        }
    }
    
    private License readLicense(String filePath) throws IOException {
        try (LicenseReader reader = new LicenseReader(filePath)) {
            return reader.read(IOFormat.BINARY);
        }
    }
    
    private boolean validateFeatures(License license) {
        // フィーチャーの検証ロジック
        return true;
    }
}
```

### フロー図

```
開始
  ↓
ライセンスファイル読み込み
  ↓
読み込み成功？ → No → エラー処理 → 終了（失敗）
  ↓ Yes
署名検証
  ↓
署名有効？ → No → エラー処理 → 終了（失敗）
  ↓ Yes
有効期限チェック
  ↓
期限内？ → No → エラー処理 → 終了（失敗）
  ↓ Yes
フィーチャー検証
  ↓
フィーチャー有効？ → No → エラー処理 → 終了（失敗）
  ↓ Yes
終了（成功）
```

---

## ライセンスファイルの読み込み

### 基本的な読み込み方法

#### BINARY形式の読み込み

```java
import javax0.license3j.License;
import javax0.license3j.io.LicenseReader;
import javax0.license3j.io.IOFormat;
import java.io.IOException;

public class LicenseLoader {
    
    public License loadBinaryLicense(String filePath) throws IOException {
        try (LicenseReader reader = new LicenseReader(filePath)) {
            return reader.read(IOFormat.BINARY);
        }
    }
    
    // デフォルトはBINARY形式
    public License loadLicense(String filePath) throws IOException {
        try (LicenseReader reader = new LicenseReader(filePath)) {
            return reader.read(); // IOFormat.BINARYと同じ
        }
    }
}
```

#### BASE64形式の読み込み

```java
public License loadBase64License(String filePath) throws IOException {
    try (LicenseReader reader = new LicenseReader(filePath)) {
        return reader.read(IOFormat.BASE64);
    }
}
```

#### STRING形式の読み込み

```java
public License loadTextLicense(String filePath) throws IOException {
    try (LicenseReader reader = new LicenseReader(filePath)) {
        return reader.read(IOFormat.STRING);
    }
}
```

### InputStreamからの読み込み

```java
import java.io.InputStream;
import java.io.FileInputStream;

public License loadFromInputStream(InputStream inputStream) throws IOException {
    try (LicenseReader reader = new LicenseReader(inputStream)) {
        return reader.read(IOFormat.BINARY);
    }
}

// クラスパスリソースから読み込む
public License loadFromClasspath(String resourcePath) throws IOException {
    InputStream is = getClass().getResourceAsStream(resourcePath);
    if (is == null) {
        throw new IOException("リソースが見つかりません: " + resourcePath);
    }
    return loadFromInputStream(is);
}
```

### ファイルサイズ制限付き読み込み

```java
import java.io.File;

public License loadWithSizeLimit(String filePath, long maxSizeBytes) 
        throws IOException {
    File file = new File(filePath);
    
    // ファイルサイズをチェック
    if (file.length() > maxSizeBytes) {
        throw new IOException("ライセンスファイルが大きすぎます: " 
            + file.length() + " bytes (最大: " + maxSizeBytes + " bytes)");
    }
    
    try (LicenseReader reader = new LicenseReader(file, maxSizeBytes)) {
        return reader.read(IOFormat.BINARY);
    }
}
```

### マジックバイトチェック付き読み込み

```java
// マジックバイトをチェックして不正なファイルを早期に検出
public License loadWithMagicCheck(String filePath) throws IOException {
    try (LicenseReader reader = new LicenseReader(filePath)) {
        // readChecking()は最初の数KBでマジックバイトをチェック
        return reader.readChecking(IOFormat.BINARY);
    }
}
```

### 複数形式対応の読み込み

```java
public License loadLicenseAutoDetect(String filePath) throws IOException {
    // ファイル拡張子から形式を判定
    IOFormat format = detectFormat(filePath);
    
    try (LicenseReader reader = new LicenseReader(filePath)) {
        return reader.read(format);
    }
}

private IOFormat detectFormat(String filePath) {
    String lowerPath = filePath.toLowerCase();
    if (lowerPath.endsWith(".bin")) {
        return IOFormat.BINARY;
    } else if (lowerPath.endsWith(".b64") || lowerPath.endsWith(".base64")) {
        return IOFormat.BASE64;
    } else if (lowerPath.endsWith(".txt")) {
        return IOFormat.STRING;
    }
    // デフォルトはBINARY
    return IOFormat.BINARY;
}
```

---

## 署名の検証

### 基本的な署名検証

```java
public class SignatureValidator {
    
    // 公開鍵（アプリケーションに埋め込む）
    private static final byte[] PUBLIC_KEY = {
        (byte)0x52, (byte)0x53, (byte)0x41, (byte)0x00,
        // ... 公開鍵のバイト配列 ...
    };
    
    /**
     * ライセンスの署名を検証する
     * @param license 検証するライセンス
     * @return 署名が有効な場合true
     */
    public boolean verifySignature(License license) {
        return license.isOK(PUBLIC_KEY);
    }
}
```

### 署名検証の詳細

```java
import java.security.PublicKey;
import javax0.license3j.crypto.LicenseKeyPair;
import java.lang.reflect.Modifier;

public class DetailedSignatureValidator {
    
    /**
     * バイト配列の公開鍵で検証
     */
    public boolean verifyWithByteArray(License license, byte[] publicKeyBytes) {
        return license.isOK(publicKeyBytes);
    }
    
    /**
     * PublicKeyオブジェクトで検証
     */
    public boolean verifyWithPublicKey(License license, PublicKey publicKey) {
        return license.isOK(publicKey);
    }
    
    /**
     * ファイルから公開鍵を読み込んで検証
     */
    public boolean verifyWithKeyFile(License license, String publicKeyPath) {
        try {
            // 公開鍵ファイルを読み込む
            byte[] keyBytes = java.nio.file.Files.readAllBytes(
                java.nio.file.Paths.get(publicKeyPath)
            );
            
            // LicenseKeyPairを使用して公開鍵を取得
            LicenseKeyPair keyPair = LicenseKeyPair.Create.from(
                keyBytes, 
                Modifier.PUBLIC
            );
            
            return license.isOK(keyPair.getPair().getPublic());
            
        } catch (Exception e) {
            System.err.println("公開鍵の読み込みエラー: " + e.getMessage());
            return false;
        }
    }
}
```

### 署名検証失敗時の詳細情報取得

```java
public class SignatureVerificationResult {
    private boolean valid;
    private String errorMessage;
    private Exception exception;
    
    public static SignatureVerificationResult verify(License license, byte[] publicKey) {
        SignatureVerificationResult result = new SignatureVerificationResult();
        
        try {
            // 署名フィーチャーの存在確認
            if (license.get("licenseSignature") == null) {
                result.valid = false;
                result.errorMessage = "ライセンスに署名が含まれていません";
                return result;
            }
            
            // ダイジェストアルゴリズムの確認
            if (license.get("signatureDigest") == null) {
                result.valid = false;
                result.errorMessage = "署名ダイジェストアルゴリズムが指定されていません";
                return result;
            }
            
            // 署名検証
            result.valid = license.isOK(publicKey);
            if (!result.valid) {
                result.errorMessage = "署名の検証に失敗しました";
            }
            
        } catch (Exception e) {
            result.valid = false;
            result.errorMessage = "署名検証中にエラーが発生しました: " + e.getMessage();
            result.exception = e;
        }
        
        return result;
    }
    
    // Getters
    public boolean isValid() { return valid; }
    public String getErrorMessage() { return errorMessage; }
    public Exception getException() { return exception; }
}
```

---

## フィーチャーの取得と検証

### 基本的なフィーチャー取得

```java
import javax0.license3j.Feature;
import java.util.Date;
import java.util.UUID;

public class FeatureExtractor {
    
    /**
     * 文字列フィーチャーの取得
     */
    public String getStringFeature(License license, String featureName) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return null;
        }
        return feature.getString();
    }
    
    /**
     * 整数フィーチャーの取得
     */
    public Integer getIntFeature(License license, String featureName) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return null;
        }
        return feature.getInt();
    }
    
    /**
     * 日付フィーチャーの取得
     */
    public Date getDateFeature(License license, String featureName) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return null;
        }
        return feature.getDate();
    }
    
    /**
     * UUIDフィーチャーの取得
     */
    public UUID getUUIDFeature(License license, String featureName) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return null;
        }
        return feature.getUUID();
    }
}
```

### 型安全なフィーチャー取得

```java
public class SafeFeatureExtractor {
    
    /**
     * デフォルト値付きで文字列フィーチャーを取得
     */
    public String getStringOrDefault(License license, String featureName, String defaultValue) {
        try {
            Feature feature = license.get(featureName);
            if (feature == null || !feature.isString()) {
                return defaultValue;
            }
            return feature.getString();
        } catch (Exception e) {
            return defaultValue;
        }
    }
    
    /**
     * デフォルト値付きで整数フィーチャーを取得
     */
    public int getIntOrDefault(License license, String featureName, int defaultValue) {
        try {
            Feature feature = license.get(featureName);
            if (feature == null || !feature.isInt()) {
                return defaultValue;
            }
            return feature.getInt();
        } catch (Exception e) {
            return defaultValue;
        }
    }
    
    /**
     * フィーチャーの存在確認
     */
    public boolean hasFeature(License license, String featureName) {
        return license.get(featureName) != null;
    }
    
    /**
     * フィーチャーの型確認
     */
    public boolean isFeatureType(License license, String featureName, Class<?> expectedType) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return false;
        }
        
        if (expectedType == String.class) {
            return feature.isString();
        } else if (expectedType == Integer.class) {
            return feature.isInt();
        } else if (expectedType == Long.class) {
            return feature.isLong();
        } else if (expectedType == Date.class) {
            return feature.isDate();
        } else if (expectedType == UUID.class) {
            return feature.isUUID();
        }
        
        return false;
    }
}
```

### 全フィーチャーの取得

```java
import java.util.Map;

public class AllFeaturesExtractor {
    
    /**
     * ライセンスの全フィーチャーを取得
     */
    public Map<String, Feature> getAllFeatures(License license) {
        return license.getFeatures();
    }
    
    /**
     * 全フィーチャーを表示
     */
    public void printAllFeatures(License license) {
        Map<String, Feature> features = license.getFeatures();
        
        System.out.println("=== ライセンスフィーチャー ===");
        for (Map.Entry<String, Feature> entry : features.entrySet()) {
            String name = entry.getKey();
            Feature feature = entry.getValue();
            
            System.out.println(name + " = " + feature.valueString());
        }
    }
}
```

### ビジネスロジックでのフィーチャー活用

```java
public class LicenseBasedFeatureControl {
    
    private License license;
    
    public LicenseBasedFeatureControl(License license) {
        this.license = license;
    }
    
    /**
     * ユーザー数制限のチェック
     */
    public boolean canAddUser(int currentUserCount) {
        Integer maxUsers = getIntOrDefault(license, "maxUsers", Integer.MAX_VALUE);
        return currentUserCount < maxUsers;
    }
    
    /**
     * 機能の有効/無効チェック
     */
    public boolean isFeatureEnabled(String featureName) {
        Feature feature = license.get(featureName);
        if (feature == null) {
            return false;
        }
        
        // BYTE型で0/1を使用
        if (feature.isByte()) {
            return feature.getByte() != 0;
        }
        
        // STRING型で"true"/"false"を使用
        if (feature.isString()) {
            return "true".equalsIgnoreCase(feature.getString());
        }
        
        return false;
    }
    
    /**
     * 同時接続数制限のチェック
     */
    public boolean canConnect(int currentConnections) {
        Integer maxConnections = getIntOrDefault(license, "maxConcurrentUsers", Integer.MAX_VALUE);
        return currentConnections < maxConnections;
    }
    
    private int getIntOrDefault(License license, String name, int defaultValue) {
        try {
            Feature feature = license.get(name);
            return feature != null ? feature.getInt() : defaultValue;
        } catch (Exception e) {
            return defaultValue;
        }
    }
}
```

---

## 有効期限のチェック

### 基本的な有効期限チェック

```java
public class ExpirationChecker {
    
    /**
     * ライセンスが期限切れかチェック
     */
    public boolean isExpired(License license) {
        try {
            return license.isExpired();
        } catch (Exception e) {
            // 有効期限フィーチャーがない場合
            System.err.println("有効期限の確認エラー: " + e.getMessage());
            return true; // 安全側に倒す
        }
    }
    
    /**
     * 有効期限を取得
     */
    public Date getExpirationDate(License license) {
        try {
            Feature expiryFeature = license.get("expiryDate");
            if (expiryFeature == null) {
                return null;
            }
            return expiryFeature.getDate();
        } catch (Exception e) {
            return null;
        }
    }
}
```

### 詳細な有効期限チェック

```java
import java.util.concurrent.TimeUnit;

public class DetailedExpirationChecker {
    
    /**
     * 有効期限までの残り日数を取得
     */
    public long getDaysUntilExpiration(License license) {
        try {
            Feature expiryFeature = license.get("expiryDate");
            if (expiryFeature == null) {
                return -1; // 有効期限が設定されていない
            }
            
            Date expiryDate = expiryFeature.getDate();
            Date now = new Date();
            
            long diffMillis = expiryDate.getTime() - now.getTime();
            return TimeUnit.MILLISECONDS.toDays(diffMillis);
            
        } catch (Exception e) {
            return -1;
        }
    }
    
    /**
     * 有効期限が近づいているか（警告表示用）
     */
    public boolean isExpiringSoon(License license, int warningDays) {
        long daysRemaining = getDaysUntilExpiration(license);
        return daysRemaining >= 0 && daysRemaining <= warningDays;
    }
    
    /**
     * 有効期限の状態を取得
     */
    public ExpirationStatus getExpirationStatus(License license) {
        try {
            if (license.isExpired()) {
                return ExpirationStatus.EXPIRED;
            }
            
            long daysRemaining = getDaysUntilExpiration(license);
            
            if (daysRemaining < 0) {
                return ExpirationStatus.NO_EXPIRATION;
            } else if (daysRemaining <= 7) {
                return ExpirationStatus.EXPIRING_SOON;
            } else if (daysRemaining <= 30) {
                return ExpirationStatus.EXPIRING_THIS_MONTH;
            } else {
                return ExpirationStatus.VALID;
            }
            
        } catch (Exception e) {
            return ExpirationStatus.ERROR;
        }
    }
    
    public enum ExpirationStatus {
        VALID,              // 有効
        EXPIRING_THIS_MONTH, // 今月中に期限切れ
        EXPIRING_SOON,      // まもなく期限切れ（7日以内）
        EXPIRED,            // 期限切れ
        NO_EXPIRATION,      // 有効期限なし
        ERROR               // エラー
    }
}
```

### 有効期限チェックのスケジューリング

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class LicenseExpirationMonitor {
    
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private License license;
    private ExpirationListener listener;
    
    public interface ExpirationListener {
        void onExpirationWarning(long daysRemaining);
        void onExpired();
    }
    
    public LicenseExpirationMonitor(License license, ExpirationListener listener) {
        this.license = license;
        this.listener = listener;
    }
    
    /**
     * 定期的な有効期限チェックを開始
     */
    public void startMonitoring() {
        // 毎日午前0時にチェック
        scheduler.scheduleAtFixedRate(
            this::checkExpiration,
            0,
            24,
            TimeUnit.HOURS
        );
    }
    
    private void checkExpiration() {
        try {
            if (license.isExpired()) {
                listener.onExpired();
                return;
            }
            
            DetailedExpirationChecker checker = new DetailedExpirationChecker();
            long daysRemaining = checker.getDaysUntilExpiration(license);
            
            // 30日以内に期限切れの場合、警告
            if (daysRemaining >= 0 && daysRemaining <= 30) {
                listener.onExpirationWarning(daysRemaining);
            }
            
        } catch (Exception e) {
            System.err.println("有効期限チェックエラー: " + e.getMessage());
        }
    }
    
    public void stopMonitoring() {
        scheduler.shutdown();
    }
}
```

---

## ハードウェアバインディング

### 基本的なハードウェアバインディング

```java
import javax0.license3j.HardwareBinder;
import java.util.UUID;

public class HardwareBinding {
    
    /**
     * 現在のマシンのUUIDを取得
     */
    public UUID getCurrentMachineId() throws Exception {
        HardwareBinder binder = new HardwareBinder();
        return binder.getMachineId();
    }
    
    /**
     * ライセンスが現在のマシンにバインドされているかチェック
     */
    public boolean isLicenseBoundToThisMachine(License license) {
        try {
            // ライセンスからマシンIDを取得
            Feature machineIdFeature = license.get("machineId");
            if (machineIdFeature == null) {
                // マシンIDが設定されていない場合は、バインディングなし
                return true;
            }
            
            UUID licensedMachineId = machineIdFeature.getUUID();
            
            // 現在のマシンIDを取得
            HardwareBinder binder = new HardwareBinder();
            UUID currentMachineId = binder.getMachineId();
            
            // 比較
            return licensedMachineId.equals(currentMachineId);
            
        } catch (Exception e) {
            System.err.println("ハードウェアバインディングチェックエラー: " + e.getMessage());
            return false;
        }
    }
}
```

### カスタマイズ可能なハードウェアバインディング

```java
import javax0.license3j.hardware.CloudProvider;

public class CustomHardwareBinding {
    
    /**
     * ネットワークインターフェースをフィルタリングしてマシンIDを取得
     */
    public UUID getMachineIdWithFiltering() throws Exception {
        HardwareBinder binder = new HardwareBinder()
            .allowed("eth.*")      // イーサネットインターフェースのみ許可
            .denied("docker.*")    // Dockerインターフェースを除外
            .denied("veth.*");     // 仮想イーサネットを除外
        
        return binder.getMachineId();
    }
    
    /**
     * クラウド環境でのマシンID取得
     */
    public UUID getCloudMachineId(CloudProvider provider) throws Exception {
        HardwareBinder binder = new HardwareBinder()
            .forCloudProvider(provider);
        
        return binder.getMachineId();
    }
    
    /**
     * ホスト名を除外してマシンIDを取得
     */
    public UUID getMachineIdWithoutHostname() throws Exception {
        HardwareBinder binder = new HardwareBinder();
        binder.ignore.hostName();
        
        return binder.getMachineId();
    }
    
    /**
     * ネットワークを除外してマシンIDを取得
     */
    public UUID getMachineIdWithoutNetwork() throws Exception {
        HardwareBinder binder = new HardwareBinder();
        binder.ignore.network();
        
        return binder.getMachineId();
    }
}
```

### 柔軟なハードウェアバインディングチェック

```java
public class FlexibleHardwareBinding {
    
    /**
     * 警告のみでハードウェアバインディングをチェック
     * （推奨: ハードウェア交換時の問題を避けるため）
     */
    public HardwareBindingResult checkHardwareBinding(License license) {
        HardwareBindingResult result = new HardwareBindingResult();
        
        try {
            Feature machineIdFeature = license.get("machineId");
            if (machineIdFeature == null) {
                result.bound = false;
                result.warning = "ライセンスにマシンIDが設定されていません";
                return result;
            }
            
            UUID licensedMachineId = machineIdFeature.getUUID();
            HardwareBinder binder = new HardwareBinder();
            UUID currentMachineId = binder.getMachineId();
            
            if (licensedMachineId.equals(currentMachineId)) {
                result.bound = true;
                result.matched = true;
            } else {
                result.bound = true;
                result.matched = false;
                result.warning = String.format(
                    "ライセンスのマシンID (%s) と現在のマシンID (%s) が一致しません",
                    licensedMachineId, currentMachineId
                );
            }
            
        } catch (Exception e) {
            result.error = e.getMessage();
        }
        
        return result;
    }
    
    public static class HardwareBindingResult {
        public boolean bound = false;      // ハードウェアバインディングが設定されているか
        public boolean matched = false;    // マシンIDが一致するか
        public String warning = null;      // 警告メッセージ
        public String error = null;        // エラーメッセージ
        
        public boolean shouldAllowExecution() {
            // エラーがなく、バインディングが設定されていないか、マッチしている場合は実行を許可
            return error == null && (!bound || matched);
        }
        
        public boolean shouldLogWarning() {
            return warning != null;
        }
    }
}
```

---

## 実装パターン

### パターン1: シングルトンライセンスマネージャー

```java
public class LicenseManager {
    
    private static LicenseManager instance;
    private License license;
    private boolean validated = false;
    
    private static final byte[] PUBLIC_KEY = {
        // ... 公開鍵 ...
    };
    
    private LicenseManager() {
        // プライベートコンストラクタ
    }
    
    public static synchronized LicenseManager getInstance() {
        if (instance == null) {
            instance = new LicenseManager();
        }
        return instance;
    }
    
    /**
     * ライセンスを初期化
     */
    public void initialize(String licenseFilePath) throws LicenseException {
        try {
            // ライセンスを読み込む
            try (LicenseReader reader = new LicenseReader(licenseFilePath)) {
                this.license = reader.read(IOFormat.BINARY);
            }
            
            // 署名を検証
            if (!license.isOK(PUBLIC_KEY)) {
                throw new LicenseException("ライセンスの署名が無効です");
            }
            
            // 有効期限をチェック
            if (license.isExpired()) {
                throw new LicenseException("ライセンスの有効期限が切れています");
            }
            
            this.validated = true;
            
        } catch (IOException e) {
            throw new LicenseException("ライセンスファイルの読み込みに失敗しました", e);
        }
    }
    
    /**
     * ライセンスが有効かチェック
     */
    public boolean isValid() {
        return validated && license != null;
    }
    
    /**
     * フィーチャーを取得
     */
    public String getFeature(String name) {
        if (!isValid()) {
            throw new IllegalStateException("ライセンスが初期化されていません");
        }
        
        Feature feature = license.get(name);
        return feature != null ? feature.getString() : null;
    }
    
    /**
     * 整数フィーチャーを取得
     */
    public int getIntFeature(String name, int defaultValue) {
        if (!isValid()) {
            return defaultValue;
        }
        
        try {
            Feature feature = license.get(name);
            return feature != null ? feature.getInt() : defaultValue;
        } catch (Exception e) {
            return defaultValue;
        }
    }
    
    public static class LicenseException extends Exception {
        public LicenseException(String message) {
            super(message);
        }
        
        public LicenseException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
```

### パターン2: Spring Boot統合

```java
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;
import javax.annotation.PostConstruct;

@Service
public class LicenseService {
    
    @Value("${license.file.path}")
    private String licenseFilePath;
    
    @Value("${license.public.key}")
    private String publicKeyBase64;
    
    private License license;
    private boolean valid = false;
    
    @PostConstruct
    public void init() {
        try {
            loadAndValidateLicense();
        } catch (Exception e) {
            // ログに記録
            System.err.println("ライセンスの初期化に失敗しました: " + e.getMessage());
        }
    }
    
    private void loadAndValidateLicense() throws Exception {
        // ライセンスを読み込む
        try (LicenseReader reader = new LicenseReader(licenseFilePath)) {
            this.license = reader.read(IOFormat.BINARY);
        }
        
        // 公開鍵をデコード
        byte[] publicKey = java.util.Base64.getDecoder().decode(publicKeyBase64);
        
        // 検証
        if (!license.isOK(publicKey)) {
            throw new Exception("ライセンスの署名が無効です");
        }
        
        if (license.isExpired()) {
            throw new Exception("ライセンスの有効期限が切れています");
        }
        
        this.valid = true;
    }
    
    public boolean isLicenseValid() {
        return valid;
    }
    
    public boolean canUseFeature(String featureName) {
        if (!valid) {
            return false;
        }
        
        try {
            Feature feature = license.get(featureName);
            if (feature == null) {
                return false;
            }
            
            if (feature.isByte()) {
                return feature.getByte() != 0;
            }
            
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    public int getMaxUsers() {
        if (!valid) {
            return 0;
        }
        
        try {
            Feature feature = license.get("maxUsers");
            return feature != null ? feature.getInt() : Integer.MAX_VALUE;
        } catch (Exception e) {
            return 0;
        }
    }
}
```

### パターン3: アスペクト指向プログラミング（AOP）

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LicenseAspect {
    
    private final LicenseService licenseService;
    
    public LicenseAspect(LicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    /**
     * ライセンスチェックアノテーション
     */
    @Around("@annotation(requiresLicense)")
    public Object checkLicense(ProceedingJoinPoint joinPoint, RequiresLicense requiresLicense) 
            throws Throwable {
        
        // ライセンスが有効かチェック
        if (!licenseService.isLicenseValid()) {
            throw new LicenseException("有効なライセンスがありません");
        }
        
        // 特定のフィーチャーが必要な場合
        String requiredFeature = requiresLicense.feature();
        if (!requiredFeature.isEmpty() && !licenseService.canUseFeature(requiredFeature)) {
            throw new LicenseException("この機能を使用するライセンスがありません: " + requiredFeature);
        }
        
        // メソッドを実行
        return joinPoint.proceed();
    }
}

// カスタムアノテーション
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiresLicense {
    String feature() default "";
}

// 使用例
@Service
public class PremiumFeatureService {
    
    @RequiresLicense(feature = "premiumReports")
    public Report generatePremiumReport() {
        // プレミアム機能の実装
        return new Report();
    }
}
```

### パターン4: キャッシュ付きライセンス検証

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public class CachedLicenseValidator {
    
    private License license;
    private final byte[] publicKey;
    private final ConcurrentHashMap<String, CachedValidation> cache = new ConcurrentHashMap<>();
    private final long cacheExpirationMillis;
    
    public CachedLicenseValidator(License license, byte[] publicKey, long cacheExpirationMinutes) {
        this.license = license;
        this.publicKey = publicKey;
        this.cacheExpirationMillis = TimeUnit.MINUTES.toMillis(cacheExpirationMinutes);
    }
    
    /**
     * キャッシュ付きでライセンスを検証
     */
    public boolean isValid() {
        String cacheKey = "license_validation";
        CachedValidation cached = cache.get(cacheKey);
        
        // キャッシュが有効な場合
        if (cached != null && !cached.isExpired()) {
            return cached.result;
        }
        
        // 検証を実行
        boolean result = performValidation();
        
        // キャッシュに保存
        cache.put(cacheKey, new CachedValidation(result, System.currentTimeMillis()));
        
        return result;
    }
    
    private boolean performValidation() {
        try {
            // 署名検証
            if (!license.isOK(publicKey)) {
                return false;
            }
            
            // 有効期限チェック
            if (license.isExpired()) {
                return false;
            }
            
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * キャッシュをクリア
     */
    public void clearCache() {
        cache.clear();
    }
    
    private class CachedValidation {
        final boolean result;
        final long timestamp;
        
        CachedValidation(boolean result, long timestamp) {
            this.result = result;
            this.timestamp = timestamp;
        }
        
        boolean isExpired() {
            return System.currentTimeMillis() - timestamp > cacheExpirationMillis;
        }
    }
}
```

---

## エラーハンドリング

### 包括的なエラーハンドリング

```java
public class RobustLicenseValidator {
    
    public ValidationResult validate(String licenseFilePath, byte[] publicKey) {
        ValidationResult result = new ValidationResult();
        
        try {
            // 1. ファイルの存在確認
            java.io.File file = new java.io.File(licenseFilePath);
            if (!file.exists()) {
                result.addError("ライセンスファイルが見つかりません: " + licenseFilePath);
                return result;
            }
            
            // 2. ファイルサイズチェック
            if (file.length() > 10 * 1024 * 1024) { // 10MB制限
                result.addError("ライセンスファイルが大きすぎます: " + file.length() + " bytes");
                return result;
            }
            
            // 3. ライセンスの読み込み
            License license;
            try (LicenseReader reader = new LicenseReader(licenseFilePath)) {
                license = reader.read(IOFormat.BINARY);
            } catch (IOException e) {
                result.addError("ライセンスファイルの読み込みに失敗しました: " + e.getMessage());
                return result;
            }
            
            // 4. 署名の検証
            if (!license.isOK(publicKey)) {
                result.addError("ライセンスの署名が無効です");
                return result;
            }
            
            // 5. 有効期限のチェック
            try {
                if (license.isExpired()) {
                    result.addError("ライセンスの有効期限が切れています");
                    
                    // 有効期限を取得して詳細情報を追加
                    Feature expiryFeature = license.get("expiryDate");
                    if (expiryFeature != null) {
                        result.addInfo("有効期限: " + expiryFeature.getDate());
                    }
                    
                    return result;
                }
            } catch (Exception e) {
                result.addWarning("有効期限の確認中にエラーが発生しました: " + e.getMessage());
            }
            
            // 6. 必須フィーチャーの確認
            if (!validateRequiredFeatures(license, result)) {
                return result;
            }
            
            result.valid = true;
            result.license = license;
            
        } catch (Exception e) {
            result.addError("予期しないエラーが発生しました: " + e.getMessage());
            e.printStackTrace();
        }
        
        return result;
    }
    
    private boolean validateRequiredFeatures(License license, ValidationResult result) {
        // 必須フィーチャーのリスト
        String[] requiredFeatures = {"owner", "product"};
        
        for (String featureName : requiredFeatures) {
            if (license.get(featureName) == null) {
                result.addWarning("必須フィーチャーが見つかりません: " + featureName);
            }
        }
        
        return true; // 警告のみで続行
    }
    
    public static class ValidationResult {
        public boolean valid = false;
        public License license = null;
        public java.util.List<String> errors = new java.util.ArrayList<>();
        public java.util.List<String> warnings = new java.util.ArrayList<>();
        public java.util.List<String> info = new java.util.ArrayList<>();
        
        public void addError(String message) {
            errors.add(message);
        }
        
        public void addWarning(String message) {
            warnings.add(message);
        }
        
        public void addInfo(String message) {
            info.add(message);
        }
        
        public boolean hasErrors() {
            return !errors.isEmpty();
        }
        
        public boolean hasWarnings() {
            return !warnings.isEmpty();
        }
        
        public String getSummary() {
            StringBuilder sb = new StringBuilder();
            
            if (valid) {
                sb.append("✓ ライセンスは有効です\n");
            } else {
                sb.append("✗ ライセンスは無効です\n");
            }
            
            if (!errors.isEmpty()) {
                sb.append("\nエラー:\n");
                for (String error : errors) {
                    sb.append("  - ").append(error).append("\n");
                }
            }
            
            if (!warnings.isEmpty()) {
                sb.append("\n警告:\n");
                for (String warning : warnings) {
                    sb.append("  - ").append(warning).append("\n");
                }
            }
            
            if (!info.isEmpty()) {
                sb.append("\n情報:\n");
                for (String infoMsg : info) {
                    sb.append("  - ").append(infoMsg).append("\n");
                }
            }
            
            return sb.toString();
        }
    }
}
```

### カスタム例外クラス

```java
public class LicenseValidationException extends Exception {
    
    private final ErrorCode errorCode;
    
    public enum ErrorCode {
        FILE_NOT_FOUND("ライセンスファイルが見つかりません"),
        INVALID_FORMAT("ライセンスファイルの形式が無効です"),
        INVALID_SIGNATURE("ライセンスの署名が無効です"),
        EXPIRED("ライセンスの有効期限が切れています"),
        HARDWARE_MISMATCH("ハードウェアIDが一致しません"),
        MISSING_FEATURE("必須フィーチャーが見つかりません"),
        UNKNOWN_ERROR("不明なエラーが発生しました");
        
        private final String message;
        
        ErrorCode(String message) {
            this.message = message;
        }
        
        public String getMessage() {
            return message;
        }
    }
    
    public LicenseValidationException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
    
    public LicenseValidationException(ErrorCode errorCode, String details) {
        super(errorCode.getMessage() + ": " + details);
        this.errorCode = errorCode;
    }
    
    public LicenseValidationException(ErrorCode errorCode, Throwable cause) {
        super(errorCode.getMessage(), cause);
        this.errorCode = errorCode;
    }
    
    public ErrorCode getErrorCode() {
        return errorCode;
    }
}
```

---

## セキュリティのベストプラクティス

### 1. 公開鍵の安全な埋め込み

```java
public class SecurePublicKeyStorage {
    
    // 公開鍵をハードコード（推奨）
    private static final byte[] PUBLIC_KEY = {
        (byte)0x52, (byte)0x53, (byte)0x41, (byte)0x00,
        (byte)0x30, (byte)0x82, (byte)0x01, (byte)0x22,
        // ... 残りの公開鍵バイト ...
    };
    
    /**
     * 公開鍵を取得（コピーを返す）
     */
    public static byte[] getPublicKey() {
        return PUBLIC_KEY.clone();
    }
    
    /**
     * 公開鍵のSHA-256ハッシュを検証
     */
    public static boolean verifyPublicKeyIntegrity() {
        try {
            java.security.MessageDigest digest = 
                java.security.MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(PUBLIC_KEY);
            
            // 期待されるハッシュ値（事前に計算）
            byte[] expectedHash = {
                // ... 期待されるハッシュ値 ...
            };
            
            return java.util.Arrays.equals(hash, expectedHash);
            
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 2. ライセンスファイルの安全な保存

```java
public class SecureLicenseStorage {
    
    /**
     * ライセンスファイルを暗号化して保存
     */
    public void saveEncryptedLicense(License license, String filePath, String password) 
            throws Exception {
        // ライセンスをバイト配列に変換
        byte[] licenseBytes = license.serialized();
        
        // パスワードベースの暗号化
        byte[] encrypted = encryptWithPassword(licenseBytes, password);
        
        // ファイルに保存
        java.nio.file.Files.write(
            java.nio.file.Paths.get(filePath),
            encrypted
        );
    }
    
    /**
     * 暗号化されたライセンスファイルを読み込み
     */
    public License loadEncryptedLicense(String filePath, String password) 
            throws Exception {
        // ファイルを読み込み
        byte[] encrypted = java.nio.file.Files.readAllBytes(
            java.nio.file.Paths.get(filePath)
        );
        
        // 復号化
        byte[] licenseBytes = decryptWithPassword(encrypted, password);
        
        // ライセンスオブジェクトに変換
        return License.Create.from(licenseBytes);
    }
    
    private byte[] encryptWithPassword(byte[] data, String password) throws Exception {
        // AES暗号化の実装
        javax.crypto.SecretKeyFactory factory = 
            javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        
        byte[] salt = new byte[16];
        new java.security.SecureRandom().nextBytes(salt);
        
        javax.crypto.spec.PBEKeySpec spec = 
            new javax.crypto.spec.PBEKeySpec(password.toCharArray(), salt, 65536, 256);
        
        byte[] keyBytes = factory.generateSecret(spec).getEncoded();
        javax.crypto.spec.SecretKeySpec key = 
            new javax.crypto.spec.SecretKeySpec(keyBytes, "AES");
        
        javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key);
        
        byte[] iv = cipher.getIV();
        byte[] encrypted = cipher.doFinal(data);
        
        // salt + IV + encrypted dataを結合
        byte[] result = new byte[salt.length + iv.length + encrypted.length];
        System.arraycopy(salt, 0, result, 0, salt.length);
        System.arraycopy(iv, 0, result, salt.length, iv.length);
        System.arraycopy(encrypted, 0, result, salt.length + iv.length, encrypted.length);
        
        return result;
    }
    
    private byte[] decryptWithPassword(byte[] data, String password) throws Exception {
        // 復号化の実装（encryptWithPasswordの逆）
        // ... 実装省略 ...
        return new byte[0]; // プレースホルダー
    }
}
```

### 3. ログ出力時の注意

```java
public class SecureLicenseLogger {
    
    /**
     * ライセンス情報を安全にログ出力
     */
    public void logLicenseInfo(License license) {
        // 機密情報を含まないフィーチャーのみログ出力
        Map<String, Feature> features = license.getFeatures();
        
        for (Map.Entry<String, Feature> entry : features.entrySet()) {
            String name = entry.getKey();
            
            // 署名などの機密情報はログに出力しない
            if (name.equals("licenseSignature") || 
                name.equals("signatureDigest")) {
                continue;
            }
            
            Feature feature = entry.getValue();
            System.out.println("Feature: " + name + " = " + maskSensitiveData(feature));
        }
    }
    
    private String maskSensitiveData(Feature feature) {
        // 機密データをマスク
        String value = feature.valueString();
        
        // 長い文字列は一部のみ表示
        if (value.length() > 50) {
            return value.substring(0, 10) + "..." + value.substring(value.length() - 10);
        }
        
        return value;
    }
}
```

---

## パフォーマンス最適化

### 1. ライセンスのキャッシング

```java
public class OptimizedLicenseManager {
    
    private volatile License cachedLicense;
    private volatile long lastLoadTime = 0;
    private final long cacheValidityMillis = 60000; // 1分
    private final Object lock = new Object();
    
    /**
     * キャッシュ付きでライセンスを取得
     */
    public License getLicense(String filePath) throws IOException {
        long currentTime = System.currentTimeMillis();
        
        // キャッシュが有効な場合
        if (cachedLicense != null && 
            (currentTime - lastLoadTime) < cacheValidityMillis) {
            return cachedLicense;
        }
        
        // キャッシュが無効な場合、再読み込み
        synchronized (lock) {
            // ダブルチェック
            if (cachedLicense != null && 
                (currentTime - lastLoadTime) < cacheValidityMillis) {
                return cachedLicense;
            }
            
            // ライセンスを読み込み
            try (LicenseReader reader = new LicenseReader(filePath)) {
                cachedLicense = reader.read(IOFormat.BINARY);
                lastLoadTime = System.currentTimeMillis();
            }
        }
        
        return cachedLicense;
    }
    
    /**
     * キャッシュを無効化
     */
    public void invalidateCache() {
        synchronized (lock) {
            cachedLicense = null;
            lastLoadTime = 0;
        }
    }
}
```

### 2. 遅延初期化

```java
public class LazyLicenseValidator {
    
    private volatile License license;
    private volatile Boolean validationResult;
    private final String licenseFilePath;
    private final byte[] publicKey;
    
    public LazyLicenseValidator(String licenseFilePath, byte[] publicKey) {
        this.licenseFilePath = licenseFilePath;
        this.publicKey = publicKey;
    }
    
    /**
     * 必要になるまでライセンスを読み込まない
     */
    public boolean isValid() {
        // 既に検証済みの場合
        if (validationResult != null) {
            return validationResult;
        }
        
        synchronized (this) {
            // ダブルチェック
            if (validationResult != null) {
                return validationResult;
            }
            
            try {
                // ライセンスを読み込み
                if (license == null) {
                    try (LicenseReader reader = new LicenseReader(licenseFilePath)) {
                        license = reader.read(IOFormat.BINARY);
                    }
                }
                
                // 検証
                validationResult = license.isOK(publicKey) && !license.isExpired();
                
            } catch (Exception e) {
                validationResult = false;
            }
        }
        
        return validationResult;
    }
}
```

### 3. バッチ検証

```java
public class BatchLicenseValidator {
    
    /**
     * 複数のライセンスを一括検証
     */
    public Map<String, Boolean> validateBatch(List<String> licenseFilePaths, byte[] publicKey) {
        Map<String, Boolean> results = new java.util.concurrent.ConcurrentHashMap<>();
        
        // 並列処理で検証
        licenseFilePaths.parallelStream().forEach(filePath -> {
            try {
                License license;
                try (LicenseReader reader = new LicenseReader(filePath)) {
                    license = reader.read(IOFormat.BINARY);
                }
                
                boolean valid = license.isOK(publicKey) && !license.isExpired();
                results.put(filePath, valid);
                
            } catch (Exception e) {
                results.put(filePath, false);
            }
        });
        
        return results;
    }
}
```

---

## まとめ

### バックエンド統合のチェックリスト

- [ ] ライセンスファイルの読み込み実装
- [ ] 公開鍵の安全な埋め込み
- [ ] 署名検証の実装
- [ ] 有効期限チェックの実装
- [ ] フィーチャー取得と検証の実装
- [ ] エラーハンドリングの実装
- [ ] ログ出力の実装（機密情報の保護）
- [ ] ハードウェアバインディング（必要な場合）
- [ ] パフォーマンス最適化（キャッシング）
- [ ] ユニットテストの作成
- [ ] 統合テストの作成

### 推奨される実装順序

1. **基本的なライセンス読み込み**: まずシンプルな読み込みを実装
2. **署名検証**: 公開鍵を埋め込んで署名を検証
3. **有効期限チェック**: 期限切れライセンスを拒否
4. **フィーチャー検証**: ビジネスロジックに必要なフィーチャーを取得
5. **エラーハンドリング**: 包括的なエラー処理を追加
6. **最適化**: キャッシングなどのパフォーマンス改善
7. **セキュリティ強化**: ログ出力の保護、暗号化など

### 参考リンク

- License3j GitHub: https://github.com/verhas/License3j
- JavaDoc: https://verhas.github.io/License3j/
- ライセンスファイル出力ガイド: `ライセンスファイル出力ガイド.md`

---

**作成日**: 2025年11月13日  
**License3jバージョン**: 3.3.0
