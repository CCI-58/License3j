# License3j 実装パターン比較ガイド

## 目次

1. [概要](#概要)
2. [パターン1: シングルトンライセンスマネージャー](#パターン1-シングルトンライセンスマネージャー)
3. [パターン2: Spring Boot統合](#パターン2-spring-boot統合)
4. [パターン3: アスペクト指向プログラミング（AOP）](#パターン3-アスペクト指向プログラミングaop)
5. [パターン4: キャッシュ付きライセンス検証](#パターン4-キャッシュ付きライセンス検証)
6. [パターン比較表](#パターン比較表)
7. [選択ガイドライン](#選択ガイドライン)
8. [パターンの組み合わせ](#パターンの組み合わせ)
9. [実装時の注意点](#実装時の注意点)

---

## 概要

このガイドでは、License3jをアプリケーションのバックエンドに統合する際の4つの主要な実装パターンについて詳しく説明します。各パターンには独自の特徴、メリット、デメリットがあり、プロジェクトの要件や規模に応じて最適なパターンを選択することが重要です。

### 4つの実装パターン

1. **シングルトンライセンスマネージャー** - シンプルで理解しやすい基本パターン
2. **Spring Boot統合** - 依存性注入とSpringエコシステムを活用
3. **アスペクト指向プログラミング（AOP）** - ビジネスロジックとライセンス検証を分離
4. **キャッシュ付きライセンス検証** - パフォーマンスと動的更新を両立

---

## パターン1: シングルトンライセンスマネージャー

### 概要

シングルトンパターンを使用して、アプリケーション全体で1つのライセンスマネージャーインスタンスを共有します。最もシンプルで理解しやすい実装パターンです。

### 特徴

- **グローバルアクセス**: アプリケーションのどこからでもアクセス可能
- **遅延初期化**: 初回アクセス時にライセンスを読み込み
- **状態の共有**: 一度読み込んだライセンス情報を全体で共有
- **フレームワーク非依存**: 純粋なJavaで実装可能

### 完全な実装例

```java
package com.example.license;

import javax0.license3j.License;
import javax0.license3j.io.IOFormat;
import javax0.license3j.io.LicenseReader;
import java.io.File;
import java.io.IOException;
import java.security.PublicKey;
import java.util.Base64;
import java.security.KeyFactory;
import java.security.spec.X509EncodedKeySpec;

/**
 * シングルトンパターンによるライセンスマネージャー
 * アプリケーション全体で1つのインスタンスを共有
 */
public class LicenseManager {
    
    // シングルトンインスタンス
    private static volatile LicenseManager instance;
    
    // ライセンスオブジェクト
    private License license;
    
    // 公開鍵（アプリケーションにハードコード）
    private static final String PUBLIC_KEY_BASE64 = 
        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA..."; // 実際の公開鍵
    
    // ライセンスファイルのパス
    private static final String LICENSE_FILE_PATH = "license.bin";
    
    // 検証結果のキャッシュ
    private Boolean isValid = null;
    
    /**
     * プライベートコンストラクタ（外部からのインスタンス化を防止）
     */
    private LicenseManager() {
        // 初期化処理はgetInstance()で行う
    }
    
    /**
     * シングルトンインスタンスを取得
     * ダブルチェックロッキングによるスレッドセーフな実装
     */
    public static LicenseManager getInstance() {
        if (instance == null) {
            synchronized (LicenseManager.class) {
                if (instance == null) {
                    instance = new LicenseManager();
                    try {
                        instance.loadLicense();
                    } catch (Exception e) {
                        throw new RuntimeException("ライセンスの読み込みに失敗しました", e);
                    }
                }
            }
        }
        return instance;
    }
    
    /**
     * ライセンスファイルを読み込む
     */
    private void loadLicense() throws IOException {
        File licenseFile = new File(LICENSE_FILE_PATH);
        if (!licenseFile.exists()) {
            throw new IOException("ライセンスファイルが見つかりません: " + LICENSE_FILE_PATH);
        }
        
        LicenseReader reader = new LicenseReader(licenseFile);
        this.license = reader.read(IOFormat.BINARY);
    }
    
    /**
     * 公開鍵を取得
     */
    private PublicKey getPublicKey() throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(PUBLIC_KEY_BASE64);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        return keyFactory.generatePublic(spec);
    }
    
    /**
     * ライセンスが有効かどうかを検証
     * 結果はキャッシュされる
     */
    public synchronized boolean isLicenseValid() {
        if (isValid != null) {
            return isValid;
        }
        
        try {
            // 署名の検証
            PublicKey publicKey = getPublicKey();
            if (!license.isOK(publicKey)) {
                isValid = false;
                return false;
            }
            
            // 有効期限のチェック
            if (license.isExpired()) {
                isValid = false;
                return false;
            }
            
            isValid = true;
            return true;
            
        } catch (Exception e) {
            System.err.println("ライセンス検証エラー: " + e.getMessage());
            isValid = false;
            return false;
        }
    }
    
    /**
     * ライセンスからフィーチャーを取得
     */
    public String getFeature(String featureName) {
        if (license == null) {
            return null;
        }
        
        var feature = license.get(featureName);
        return feature != null ? feature.getString() : null;
    }
    
    /**
     * 整数型フィーチャーを取得
     */
    public Integer getIntFeature(String featureName) {
        if (license == null) {
            return null;
        }
        
        var feature = license.get(featureName);
        return feature != null && feature.isInt() ? feature.getInt() : null;
    }
    
    /**
     * ライセンス情報を文字列として取得（デバッグ用）
     */
    public String getLicenseInfo() {
        if (license == null) {
            return "ライセンスが読み込まれていません";
        }
        return license.toString();
    }
    
    /**
     * ライセンスを再読み込み（必要に応じて）
     */
    public synchronized void reloadLicense() throws IOException {
        isValid = null;
        loadLicense();
    }
}
```

### 使用例

```java
package com.example.app;

public class Application {
    
    public static void main(String[] args) {
        // ライセンスマネージャーのインスタンスを取得
        LicenseManager licenseManager = LicenseManager.getInstance();
        
        // ライセンスの検証
        if (!licenseManager.isLicenseValid()) {
            System.err.println("無効なライセンスです。アプリケーションを終了します。");
            System.exit(1);
        }
        
        System.out.println("ライセンスは有効です。");
        
        // フィーチャーの取得
        String companyName = licenseManager.getFeature("companyName");
        Integer maxUsers = licenseManager.getIntFeature("maxUsers");
        
        System.out.println("会社名: " + companyName);
        System.out.println("最大ユーザー数: " + maxUsers);
        
        // アプリケーションのメイン処理
        runApplication(maxUsers);
    }
    
    private static void runApplication(Integer maxUsers) {
        // ビジネスロジック
        System.out.println("アプリケーションを起動しました（最大ユーザー数: " + maxUsers + "）");
    }
}
```

### メリット

1. **シンプルさ**
   - 実装が非常にシンプルで理解しやすい
   - 初心者でも容易に実装できる
   - コード量が少ない

2. **フレームワーク非依存**
   - 外部フレームワークに依存しない
   - どんなJavaアプリケーションでも使用可能
   - 依存関係の管理が不要

3. **効率性**
   - ライセンスファイルの読み込みが1回だけ
   - メモリ使用量が最小限
   - オーバーヘッドがほとんどない

4. **グローバルアクセス**
   - アプリケーションのどこからでもアクセス可能
   - インスタンスの受け渡しが不要

### デメリット

1. **テストの困難さ**
   - グローバルな状態を持つため、単体テストが難しい
   - モックやスタブへの置き換えが困難
   - テスト間の独立性を保つのが難しい

2. **柔軟性の欠如**
   - 複数のライセンスを扱うことができない
   - ライセンスの動的な切り替えが困難
   - 設定の外部化が難しい

3. **スレッドセーフティ**
   - マルチスレッド環境では同期処理が必要
   - パフォーマンスへの影響がある可能性
   - デッドロックのリスク

4. **依存性注入との相性**
   - DIコンテナとの統合が不自然
   - 依存関係の明示的な管理ができない

### 適用場面

- **小規模アプリケーション**: 数百行から数千行程度のコード
- **スタンドアロンアプリケーション**: デスクトップアプリやCLIツール
- **シンプルなライセンス要件**: 起動時に1回だけ検証すれば十分
- **フレームワーク未使用**: 純粋なJavaアプリケーション
- **プロトタイプ開発**: 迅速な実装が必要な場合

### 実装時の注意点

1. **スレッドセーフティの確保**
   ```java
   // ダブルチェックロッキングを使用
   if (instance == null) {
       synchronized (LicenseManager.class) {
           if (instance == null) {
               instance = new LicenseManager();
           }
       }
   }
   ```

2. **例外処理の徹底**
   ```java
   try {
       instance.loadLicense();
   } catch (Exception e) {
       // ログ出力やエラーハンドリング
       throw new RuntimeException("ライセンスの初期化に失敗", e);
   }
   ```

3. **公開鍵の安全な管理**
   - 公開鍵はソースコードに直接埋め込む
   - Base64エンコードして定数として定義
   - 難読化ツールの使用を検討

---

## パターン2: Spring Boot統合

### 概要

Spring FrameworkのDI（依存性注入）コンテナを活用し、ライセンスマネージャーをSpring Beanとして管理します。Spring Bootアプリケーションに最適なパターンです。

### 特徴

- **依存性注入**: Spring DIコンテナによる管理
- **設定の外部化**: application.properties/ymlで設定
- **ライフサイクル管理**: Springによる初期化と破棄
- **テスタビリティ**: モックやスタブへの置き換えが容易

### 完全な実装例

#### 1. application.properties

```properties
# ライセンス設定
license.file.path=license.bin
license.public.key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...

# ライセンス検証の有効化/無効化（開発環境では無効化可能）
license.validation.enabled=true

# ライセンスチェックの厳格さ
license.validation.strict=true
```

#### 2. LicenseProperties.java（設定クラス）

```java
package com.example.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * ライセンス関連の設定プロパティ
 */
@Component
@ConfigurationProperties(prefix = "license")
public class LicenseProperties {
    
    private File file = new File();
    private String publicKey;
    private Validation validation = new Validation();
    
    public static class File {
        private String path = "license.bin";
        
        public String getPath() {
            return path;
        }
        
        public void setPath(String path) {
            this.path = path;
        }
    }
    
    public static class Validation {
        private boolean enabled = true;
        private boolean strict = true;
        
        public boolean isEnabled() {
            return enabled;
        }
        
        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }
        
        public boolean isStrict() {
            return strict;
        }
        
        public void setStrict(boolean strict) {
            this.strict = strict;
        }
    }
    
    // Getters and Setters
    public File getFile() {
        return file;
    }
    
    public void setFile(File file) {
        this.file = file;
    }
    
    public String getPublicKey() {
        return publicKey;
    }
    
    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }
    
    public Validation getValidation() {
        return validation;
    }
    
    public void setValidation(Validation validation) {
        this.validation = validation;
    }
}
```

#### 3. LicenseService.java（サービスクラス）

```java
package com.example.service;

import com.example.config.LicenseProperties;
import javax0.license3j.License;
import javax0.license3j.io.IOFormat;
import javax0.license3j.io.LicenseReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.File;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.Optional;

/**
 * ライセンス管理サービス
 * Spring Beanとして管理され、DIコンテナから注入される
 */
@Service
public class LicenseService {
    
    private static final Logger logger = LoggerFactory.getLogger(LicenseService.class);
    
    private final LicenseProperties properties;
    private License license;
    private PublicKey publicKey;
    private Boolean validationResult;
    
    /**
     * コンストラクタインジェクション（推奨）
     */
    public LicenseService(LicenseProperties properties) {
        this.properties = properties;
    }
    
    /**
     * Bean初期化後に自動実行される
     */
    @PostConstruct
    public void initialize() {
        logger.info("ライセンスサービスを初期化しています...");
        
        if (!properties.getValidation().isEnabled()) {
            logger.warn("ライセンス検証が無効化されています");
            return;
        }
        
        try {
            loadPublicKey();
            loadLicense();
            validateLicense();
            logger.info("ライセンスサービスの初期化が完了しました");
        } catch (Exception e) {
            logger.error("ライセンスサービスの初期化に失敗しました", e);
            if (properties.getValidation().isStrict()) {
                throw new RuntimeException("ライセンスの初期化に失敗しました", e);
            }
        }
    }
    
    /**
     * 公開鍵を読み込む
     */
    private void loadPublicKey() throws Exception {
        String publicKeyBase64 = properties.getPublicKey();
        if (publicKeyBase64 == null || publicKeyBase64.isEmpty()) {
            throw new IllegalStateException("公開鍵が設定されていません");
        }
        
        byte[] keyBytes = Base64.getDecoder().decode(publicKeyBase64);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        this.publicKey = keyFactory.generatePublic(spec);
        
        logger.debug("公開鍵を読み込みました");
    }
    
    /**
     * ライセンスファイルを読み込む
     */
    private void loadLicense() throws Exception {
        String licensePath = properties.getFile().getPath();
        File licenseFile = new File(licensePath);
        
        if (!licenseFile.exists()) {
            throw new IllegalStateException("ライセンスファイルが見つかりません: " + licensePath);
        }
        
        LicenseReader reader = new LicenseReader(licenseFile);
        this.license = reader.read(IOFormat.BINARY);
        
        logger.info("ライセンスファイルを読み込みました: {}", licensePath);
    }
    
    /**
     * ライセンスを検証する
     */
    private void validateLicense() {
        if (license == null || publicKey == null) {
            validationResult = false;
            return;
        }
        
        // 署名の検証
        if (!license.isOK(publicKey)) {
            logger.error("ライセンスの署名が無効です");
            validationResult = false;
            return;
        }
        
        // 有効期限のチェック
        if (license.isExpired()) {
            logger.error("ライセンスの有効期限が切れています");
            validationResult = false;
            return;
        }
        
        validationResult = true;
        logger.info("ライセンスは有効です");
    }
    
    /**
     * ライセンスが有効かどうかを返す
     */
    public boolean isValid() {
        if (!properties.getValidation().isEnabled()) {
            return true; // 検証が無効化されている場合は常にtrue
        }
        return validationResult != null && validationResult;
    }
    
    /**
     * フィーチャーを取得
     */
    public Optional<String> getFeature(String featureName) {
        if (license == null) {
            return Optional.empty();
        }
        
        var feature = license.get(featureName);
        return feature != null ? Optional.of(feature.getString()) : Optional.empty();
    }
    
    /**
     * 整数型フィーチャーを取得
     */
    public Optional<Integer> getIntFeature(String featureName) {
        if (license == null) {
            return Optional.empty();
        }
        
        var feature = license.get(featureName);
        return feature != null && feature.isInt() 
            ? Optional.of(feature.getInt()) 
            : Optional.empty();
    }
    
    /**
     * ライセンスを再読み込み
     */
    public void reload() {
        logger.info("ライセンスを再読み込みしています...");
        validationResult = null;
        initialize();
    }
    
    /**
     * ライセンス情報を取得（デバッグ用）
     */
    public String getLicenseInfo() {
        return license != null ? license.toString() : "ライセンスが読み込まれていません";
    }
}
```

#### 4. LicenseValidationException.java（カスタム例外）

```java
package com.example.exception;

/**
 * ライセンス検証失敗時の例外
 */
public class LicenseValidationException extends RuntimeException {
    
    public LicenseValidationException(String message) {
        super(message);
    }
    
    public LicenseValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

#### 5. ApplicationStartupListener.java（起動時チェック）

```java
package com.example.listener;

import com.example.exception.LicenseValidationException;
import com.example.service.LicenseService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

/**
 * アプリケーション起動時にライセンスをチェック
 */
@Component
public class ApplicationStartupListener {
    
    private static final Logger logger = LoggerFactory.getLogger(ApplicationStartupListener.class);
    
    private final LicenseService licenseService;
    
    public ApplicationStartupListener(LicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        logger.info("アプリケーション起動時のライセンスチェックを実行しています...");
        
        if (!licenseService.isValid()) {
            logger.error("無効なライセンスです。アプリケーションを終了します。");
            throw new LicenseValidationException("ライセンスが無効です");
        }
        
        // フィーチャー情報をログ出力
        licenseService.getFeature("companyName")
            .ifPresent(name -> logger.info("ライセンス所有者: {}", name));
        licenseService.getIntFeature("maxUsers")
            .ifPresent(max -> logger.info("最大ユーザー数: {}", max));
        
        logger.info("ライセンスチェックが完了しました");
    }
}
```

#### 6. 使用例（コントローラー）

```java
package com.example.controller;

import com.example.service.LicenseService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * ライセンス情報を提供するREST API
 */
@RestController
@RequestMapping("/api/license")
public class LicenseController {
    
    private final LicenseService licenseService;
    
    public LicenseController(LicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    @GetMapping("/status")
    public Map<String, Object> getLicenseStatus() {
        Map<String, Object> status = new HashMap<>();
        status.put("valid", licenseService.isValid());
        status.put("companyName", licenseService.getFeature("companyName").orElse("N/A"));
        status.put("maxUsers", licenseService.getIntFeature("maxUsers").orElse(0));
        return status;
    }
    
    @GetMapping("/reload")
    public Map<String, String> reloadLicense() {
        licenseService.reload();
        Map<String, String> result = new HashMap<>();
        result.put("message", "ライセンスを再読み込みしました");
        result.put("valid", String.valueOf(licenseService.isValid()));
        return result;
    }
}
```

### メリット

1. **依存性注入の活用**
   - DIコンテナによる自動的な依存関係の解決
   - コンストラクタインジェクションで依存関係が明確
   - インターフェースベースの設計が容易

2. **設定の外部化**
   - application.propertiesで設定を管理
   - 環境ごとに異なる設定ファイルを使用可能
   - プロファイル機能で開発/本番環境を切り替え

3. **テスタビリティの向上**
   - モックやスタブへの置き換えが容易
   - `@MockBean`を使用した単体テスト
   - 統合テストでの柔軟な設定

4. **Springエコシステムとの統合**
   - Spring Securityとの連携
   - Spring Bootのヘルスチェック機能
   - Spring Actuatorでの監視

5. **ライフサイクル管理**
   - `@PostConstruct`で初期化処理
   - `@PreDestroy`でクリーンアップ処理
   - Springによる適切なリソース管理

### デメリット

1. **Spring依存**
   - Spring Frameworkへの依存が必須
   - 学習コストが高い
   - 小規模アプリケーションには過剰

2. **起動時間の増加**
   - DIコンテナの初期化にオーバーヘッド
   - Beanのスキャンと生成に時間がかかる
   - 小規模アプリでは顕著

3. **複雑性の増加**
   - 設定ファイルの管理が必要
   - アノテーションの理解が必要
   - デバッグが複雑になる場合がある

### 適用場面

- **Spring Bootアプリケーション**: すでにSpring Bootを使用している場合
- **マイクロサービス**: 複数のサービスで統一的なライセンス管理
- **エンタープライズアプリケーション**: 大規模で複雑なビジネスロジック
- **REST API**: Web APIとしてライセンス情報を提供
- **複数環境のデプロイ**: 開発、ステージング、本番環境

### 実装時の注意点

1. **環境別設定ファイル**
   ```
   application.properties          # 共通設定
   application-dev.properties      # 開発環境
   application-prod.properties     # 本番環境
   ```

2. **テスト用の設定**
   ```java
   @TestConfiguration
   public class TestLicenseConfig {
       @Bean
       @Primary
       public LicenseService mockLicenseService() {
           return Mockito.mock(LicenseService.class);
       }
   }
   ```

3. **条件付きBean生成**
   ```java
   @Service
   @ConditionalOnProperty(name = "license.validation.enabled", havingValue = "true")
   public class LicenseService {
       // ...
   }
   ```

---

## パターン3: アスペクト指向プログラミング（AOP）

### 概要

AOPを使用して、ビジネスロジックとライセンス検証ロジックを完全に分離します。カスタムアノテーションでライセンスが必要な機能をマークし、アスペクトが自動的にライセンスチェックを実行します。

### 特徴

- **関心の分離**: ビジネスロジックとライセンス検証を分離
- **宣言的なライセンス制御**: アノテーションで制御
- **横断的関心事**: 複数のメソッドに共通の処理を適用
- **非侵入的**: 既存コードへの影響を最小化

### 完全な実装例

#### 1. pom.xml（依存関係）

```xml
<dependencies>
    <!-- Spring Boot Starter AOP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    
    <!-- License3j -->
    <dependency>
        <groupId>com.javax0.license3j</groupId>
        <artifactId>license3j</artifactId>
        <version>3.3.0</version>
    </dependency>
</dependencies>
```

#### 2. RequiresLicense.java（カスタムアノテーション）

```java
package com.example.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * ライセンスが必要なメソッドに付与するアノテーション
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiresLicense {
    
    /**
     * 必要なフィーチャー名（オプション）
     */
    String feature() default "";
    
    /**
     * フィーチャーの期待値（オプション）
     */
    String value() default "";
    
    /**
     * ライセンスチェック失敗時のメッセージ
     */
    String message() default "この機能を使用するには有効なライセンスが必要です";
}
```

#### 3. RequiresFeature.java（フィーチャー指定アノテーション）

```java
package com.example.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 特定のフィーチャーが必要なメソッドに付与するアノテーション
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiresFeature {
    
    /**
     * 必要なフィーチャー名
     */
    String name();
    
    /**
     * フィーチャーの期待値（オプション）
     * 指定した場合、フィーチャーの値がこの値と一致する必要がある
     */
    String value() default "";
    
    /**
     * 整数型フィーチャーの最小値（オプション）
     */
    int minValue() default Integer.MIN_VALUE;
    
    /**
     * エラーメッセージ
     */
    String message() default "この機能を使用するには特定のライセンスフィーチャーが必要です";
}
```

#### 4. LicenseAspect.java（アスペクト）

```java
package com.example.aspect;

import com.example.annotation.RequiresFeature;
import com.example.annotation.RequiresLicense;
import com.example.exception.LicenseValidationException;
import com.example.service.LicenseService;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

/**
 * ライセンスチェックを行うアスペクト
 * @RequiresLicenseまたは@RequiresFeatureアノテーションが付与されたメソッドの実行前に
 * ライセンスを検証する
 */
@Aspect
@Component
@Order(1) // 他のアスペクトより先に実行
public class LicenseAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LicenseAspect.class);
    
    private final LicenseService licenseService;
    
    public LicenseAspect(LicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    /**
     * @RequiresLicenseアノテーションが付与されたメソッドの実行前にライセンスをチェック
     */
    @Around("@annotation(com.example.annotation.RequiresLicense) || @within(com.example.annotation.RequiresLicense)")
    public Object checkLicense(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        
        // メソッドまたはクラスからアノテーションを取得
        RequiresLicense annotation = method.getAnnotation(RequiresLicense.class);
        if (annotation == null) {
            annotation = method.getDeclaringClass().getAnnotation(RequiresLicense.class);
        }
        
        logger.debug("ライセンスチェック: {}.{}", 
            method.getDeclaringClass().getSimpleName(), 
            method.getName());
        
        // ライセンスの有効性をチェック
        if (!licenseService.isValid()) {
            String message = annotation != null ? annotation.message() : "無効なライセンスです";
            logger.error("ライセンスチェック失敗: {}", message);
            throw new LicenseValidationException(message);
        }
        
        // フィーチャーのチェック（指定されている場合）
        if (annotation != null && !annotation.feature().isEmpty()) {
            checkFeature(annotation.feature(), annotation.value(), annotation.message());
        }
        
        // メソッドを実行
        return joinPoint.proceed();
    }
    
    /**
     * @RequiresFeatureアノテーションが付与されたメソッドの実行前にフィーチャーをチェック
     */
    @Around("@annotation(com.example.annotation.RequiresFeature) || @within(com.example.annotation.RequiresFeature)")
    public Object checkFeature(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        
        // メソッドまたはクラスからアノテーションを取得
        RequiresFeature annotation = method.getAnnotation(RequiresFeature.class);
        if (annotation == null) {
            annotation = method.getDeclaringClass().getAnnotation(RequiresFeature.class);
        }
        
        if (annotation == null) {
            return joinPoint.proceed();
        }
        
        logger.debug("フィーチャーチェック: {} (feature={})", 
            method.getName(), 
            annotation.name());
        
        // まずライセンスの有効性をチェック
        if (!licenseService.isValid()) {
            throw new LicenseValidationException("無効なライセンスです");
        }
        
        // フィーチャーの存在と値をチェック
        String featureName = annotation.name();
        
        // 文字列型フィーチャーのチェック
        if (!annotation.value().isEmpty()) {
            String actualValue = licenseService.getFeature(featureName)
                .orElseThrow(() -> new LicenseValidationException(
                    "必要なフィーチャーが見つかりません: " + featureName));
            
            if (!actualValue.equals(annotation.value())) {
                throw new LicenseValidationException(
                    String.format("フィーチャー '%s' の値が一致しません（期待値: %s, 実際: %s）",
                        featureName, annotation.value(), actualValue));
            }
        }
        
        // 整数型フィーチャーの最小値チェック
        if (annotation.minValue() != Integer.MIN_VALUE) {
            Integer actualValue = licenseService.getIntFeature(featureName)
                .orElseThrow(() -> new LicenseValidationException(
                    "必要なフィーチャーが見つかりません: " + featureName));
            
            if (actualValue < annotation.minValue()) {
                throw new LicenseValidationException(
                    String.format("フィーチャー '%s' の値が最小値を下回っています（最小値: %d, 実際: %d）",
                        featureName, annotation.minValue(), actualValue));
            }
        }
        
        // メソッドを実行
        return joinPoint.proceed();
    }
    
    /**
     * フィーチャーの存在と値をチェック
     */
    private void checkFeature(String featureName, String expectedValue, String errorMessage) {
        if (featureName.isEmpty()) {
            return;
        }
        
        var feature = licenseService.getFeature(featureName);
        if (feature.isEmpty()) {
            throw new LicenseValidationException(
                errorMessage + " (フィーチャー '" + featureName + "' が見つかりません)");
        }
        
        if (!expectedValue.isEmpty() && !feature.get().equals(expectedValue)) {
            throw new LicenseValidationException(
                errorMessage + " (フィーチャー '" + featureName + "' の値が一致しません)");
        }
    }
}
```

#### 5. 使用例（サービスクラス）

```java
package com.example.service;

import com.example.annotation.RequiresFeature;
import com.example.annotation.RequiresLicense;
import org.springframework.stereotype.Service;

/**
 * ビジネスロジックを含むサービスクラス
 * アノテーションでライセンス制御を宣言的に行う
 */
@Service
public class BusinessService {
    
    /**
     * 基本機能 - ライセンスが必要
     */
    @RequiresLicense(message = "基本機能を使用するには有効なライセンスが必要です")
    public String basicFeature() {
        return "基本機能を実行しました";
    }
    
    /**
     * プレミアム機能 - 特定のフィーチャーが必要
     */
    @RequiresFeature(
        name = "premiumEnabled",
        value = "true",
        message = "プレミアム機能を使用するにはプレミアムライセンスが必要です"
    )
    public String premiumFeature() {
        return "プレミアム機能を実行しました";
    }
    
    /**
     * ユーザー数制限のある機能
     */
    @RequiresFeature(
        name = "maxUsers",
        minValue = 10,
        message = "この機能を使用するには10ユーザー以上のライセンスが必要です"
    )
    public String multiUserFeature(int userCount) {
        return String.format("%d ユーザーでマルチユーザー機能を実行しました", userCount);
    }
    
    /**
     * ライセンス不要の機能
     */
    public String freeFeature() {
        return "無料機能を実行しました（ライセンス不要）";
    }
}
```

#### 6. クラスレベルでのアノテーション使用例

```java
package com.example.service;

import com.example.annotation.RequiresLicense;
import org.springframework.stereotype.Service;

/**
 * クラス全体にライセンスチェックを適用
 * このクラスのすべてのpublicメソッドでライセンスがチェックされる
 */
@Service
@RequiresLicense(message = "管理機能を使用するには有効なライセンスが必要です")
public class AdminService {
    
    public String createUser(String username) {
        return "ユーザーを作成しました: " + username;
    }
    
    public String deleteUser(String username) {
        return "ユーザーを削除しました: " + username;
    }
    
    public String updateSettings(String key, String value) {
        return String.format("設定を更新しました: %s = %s", key, value);
    }
}
```

#### 7. コントローラーでの使用例

```java
package com.example.controller;

import com.example.service.BusinessService;
import org.springframework.web.bind.annotation.*;

/**
 * REST APIコントローラー
 * サービスメソッドを呼び出すだけで、自動的にライセンスチェックが実行される
 */
@RestController
@RequestMapping("/api")
public class ApiController {
    
    private final BusinessService businessService;
    
    public ApiController(BusinessService businessService) {
        this.businessService = businessService;
    }
    
    @GetMapping("/basic")
    public String basicFeature() {
        // ライセンスチェックは自動的に実行される
        return businessService.basicFeature();
    }
    
    @GetMapping("/premium")
    public String premiumFeature() {
        // プレミアムフィーチャーのチェックは自動的に実行される
        return businessService.premiumFeature();
    }
    
    @GetMapping("/multi-user")
    public String multiUserFeature(@RequestParam int userCount) {
        // ユーザー数のチェックは自動的に実行される
        return businessService.multiUserFeature(userCount);
    }
    
    @GetMapping("/free")
    public String freeFeature() {
        // ライセンスチェックなし
        return businessService.freeFeature();
    }
}
```

#### 8. グローバル例外ハンドラー

```java
package com.example.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * ライセンス検証エラーをHTTPレスポンスに変換
 */
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    @ExceptionHandler(LicenseValidationException.class)
    public ResponseEntity<Map<String, Object>> handleLicenseValidationException(
            LicenseValidationException ex) {
        
        logger.warn("ライセンス検証エラー: {}", ex.getMessage());
        
        Map<String, Object> error = new HashMap<>();
        error.put("error", "LICENSE_VALIDATION_FAILED");
        error.put("message", ex.getMessage());
        error.put("status", HttpStatus.FORBIDDEN.value());
        
        return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body(error);
    }
}
```

### メリット

1. **関心の分離**
   - ビジネスロジックとライセンス検証が完全に分離
   - コードの可読性が向上
   - メンテナンスが容易

2. **宣言的な制御**
   - アノテーションを付けるだけで簡単に適用
   - コードの意図が明確
   - 設定ミスが少ない

3. **既存コードへの影響最小**
   - 既存のメソッドにアノテーションを追加するだけ
   - ビジネスロジックの変更不要
   - 段階的な導入が可能

4. **一元管理**
   - ライセンス検証ロジックが1箇所に集約
   - 変更時の影響範囲が明確
   - テストが容易

5. **柔軟な制御**
   - メソッドレベルまたはクラスレベルで適用
   - フィーチャーごとの細かい制御
   - 複数のアノテーションの組み合わせ

### デメリット

1. **学習コストの高さ**
   - AOPの概念理解が必要
   - アスペクトの動作を理解する必要
   - デバッグが難しい場合がある

2. **デバッグの困難さ**
   - アスペクトがいつ実行されるか分かりにくい
   - スタックトレースが複雑
   - IDEのサポートが限定的

3. **パフォーマンスオーバーヘッド**
   - プロキシ生成のコスト
   - メソッド呼び出しごとのオーバーヘッド
   - リフレクションの使用

4. **制限事項**
   - 同じクラス内のメソッド呼び出しでは動作しない
   - privateメソッドには適用できない
   - finalクラス/メソッドには適用できない

5. **依存関係**
   - Spring AOPまたはAspectJへの依存
   - フレームワークのバージョン互換性

### 適用場面

- **大規模エンタープライズアプリケーション**: 複雑なビジネスロジック
- **既存システムへの後付け**: ライセンス機能を追加する場合
- **フィーチャーごとの細かい制御**: 機能ごとに異なるライセンス要件
- **複数開発者のプロジェクト**: ライセンス検証を統一的に管理
- **REST API**: エンドポイントごとのライセンス制御

### 実装時の注意点

1. **プロキシの制限を理解する**
   ```java
   @Service
   public class MyService {
       @RequiresLicense
       public void publicMethod() {
           // これは動作する
           privateMethod(); // これはライセンスチェックされない
       }
       
       private void privateMethod() {
           // privateメソッドはAOPの対象外
       }
   }
   ```

2. **アスペクトの実行順序**
   ```java
   @Aspect
   @Order(1) // 数字が小さいほど先に実行
   public class LicenseAspect {
       // ...
   }
   ```

3. **パフォーマンスの考慮**
   - 頻繁に呼ばれるメソッドでは注意
   - キャッシュとの組み合わせを検討
   - 必要な箇所にのみ適用

---

## パターン4: キャッシュ付きライセンス検証

### 概要

ライセンス検証結果をキャッシュし、一定時間再利用することでパフォーマンスを最適化します。定期的にライセンスを再検証することで、ライセンスファイルの変更や有効期限の更新に動的に対応します。

### 特徴

- **パフォーマンス最適化**: 検証結果のキャッシュ
- **動的更新対応**: 定期的な再検証
- **TTL（Time To Live）**: キャッシュの有効期限
- **スレッドセーフ**: 並行アクセスへの対応

### 完全な実装例

#### 1. CachedLicenseService.java

```java
package com.example.service;

import com.example.config.LicenseProperties;
import javax0.license3j.License;
import javax0.license3j.io.IOFormat;
import javax0.license3j.io.LicenseReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.File;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.time.Duration;
import java.time.Instant;
import java.util.Base64;
import java.util.Optional;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * キャッシュ機能付きライセンスサービス
 * 検証結果をキャッシュし、定期的に再検証する
 */
@Service
public class CachedLicenseService {
    
    private static final Logger logger = LoggerFactory.getLogger(CachedLicenseService.class);
    
    private final LicenseProperties properties;
    
    // ライセンスデータ
    private License license;
    private PublicKey publicKey;
    
    // キャッシュデータ
    private ValidationResult cachedResult;
    private Instant lastValidationTime;
    private final Duration cacheTTL = Duration.ofMinutes(5); // キャッシュの有効期限
    
    // スレッドセーフティのためのロック
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    /**
     * 検証結果を保持するクラス
     */
    private static class ValidationResult {
        private final boolean valid;
        private final String message;
        private final Instant timestamp;
        
        public ValidationResult(boolean valid, String message) {
            this.valid = valid;
            this.message = message;
            this.timestamp = Instant.now();
        }
        
        public boolean isValid() {
            return valid;
        }
        
        public String getMessage() {
            return message;
        }
        
        public Instant getTimestamp() {
            return timestamp;
        }
    }
    
    public CachedLicenseService(LicenseProperties properties) {
        this.properties = properties;
    }
    
    @PostConstruct
    public void initialize() {
        logger.info("キャッシュ付きライセンスサービスを初期化しています...");
        
        try {
            loadPublicKey();
            loadLicense();
            validateAndCache();
            logger.info("ライセンスサービスの初期化が完了しました");
        } catch (Exception e) {
            logger.error("ライセンスサービスの初期化に失敗しました", e);
            if (properties.getValidation().isStrict()) {
                throw new RuntimeException("ライセンスの初期化に失敗しました", e);
            }
        }
    }
    
    /**
     * 公開鍵を読み込む
     */
    private void loadPublicKey() throws Exception {
        String publicKeyBase64 = properties.getPublicKey();
        if (publicKeyBase64 == null || publicKeyBase64.isEmpty()) {
            throw new IllegalStateException("公開鍵が設定されていません");
        }
        
        byte[] keyBytes = Base64.getDecoder().decode(publicKeyBase64);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        this.publicKey = keyFactory.generatePublic(spec);
        
        logger.debug("公開鍵を読み込みました");
    }
    
    /**
     * ライセンスファイルを読み込む
     */
    private void loadLicense() throws Exception {
        String licensePath = properties.getFile().getPath();
        File licenseFile = new File(licensePath);
        
        if (!licenseFile.exists()) {
            throw new IllegalStateException("ライセンスファイルが見つかりません: " + licensePath);
        }
        
        LicenseReader reader = new LicenseReader(licenseFile);
        this.license = reader.read(IOFormat.BINARY);
        
        logger.info("ライセンスファイルを読み込みました: {}", licensePath);
    }
    
    /**
     * ライセンスを検証してキャッシュに保存
     */
    private void validateAndCache() {
        lock.writeLock().lock();
        try {
            if (license == null || publicKey == null) {
                cachedResult = new ValidationResult(false, "ライセンスまたは公開鍵が読み込まれていません");
                lastValidationTime = Instant.now();
                return;
            }
            
            // 署名の検証
            if (!license.isOK(publicKey)) {
                cachedResult = new ValidationResult(false, "ライセンスの署名が無効です");
                lastValidationTime = Instant.now();
                logger.error("ライセンスの署名が無効です");
                return;
            }
            
            // 有効期限のチェック
            if (license.isExpired()) {
                cachedResult = new ValidationResult(false, "ライセンスの有効期限が切れています");
                lastValidationTime = Instant.now();
                logger.error("ライセンスの有効期限が切れています");
                return;
            }
            
            cachedResult = new ValidationResult(true, "ライセンスは有効です");
            lastValidationTime = Instant.now();
            logger.info("ライセンスは有効です（キャッシュを更新しました）");
            
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * キャッシュが有効かどうかをチェック
     */
    private boolean isCacheValid() {
        if (cachedResult == null || lastValidationTime == null) {
            return false;
        }
        
        Duration elapsed = Duration.between(lastValidationTime, Instant.now());
        return elapsed.compareTo(cacheTTL) < 0;
    }
    
    /**
     * ライセンスが有効かどうかを返す（キャッシュを使用）
     */
    public boolean isValid() {
        if (!properties.getValidation().isEnabled()) {
            return true;
        }
        
        // 読み取りロックを取得
        lock.readLock().lock();
        try {
            // キャッシュが有効な場合はキャッシュから返す
            if (isCacheValid()) {
                logger.debug("キャッシュからライセンス検証結果を返します");
                return cachedResult.isValid();
            }
        } finally {
            lock.readLock().unlock();
        }
        
        // キャッシュが無効な場合は再検証
        logger.debug("キャッシュが無効なため、ライセンスを再検証します");
        validateAndCache();
        
        lock.readLock().lock();
        try {
            return cachedResult != null && cachedResult.isValid();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * 検証結果の詳細を取得
     */
    public ValidationResult getValidationResult() {
        lock.readLock().lock();
        try {
            if (!isCacheValid()) {
                validateAndCache();
            }
            return cachedResult;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * フィーチャーを取得
     */
    public Optional<String> getFeature(String featureName) {
        lock.readLock().lock();
        try {
            if (license == null) {
                return Optional.empty();
            }
            
            var feature = license.get(featureName);
            return feature != null ? Optional.of(feature.getString()) : Optional.empty();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * 整数型フィーチャーを取得
     */
    public Optional<Integer> getIntFeature(String featureName) {
        lock.readLock().lock();
        try {
            if (license == null) {
                return Optional.empty();
            }
            
            var feature = license.get(featureName);
            return feature != null && feature.isInt() 
                ? Optional.of(feature.getInt()) 
                : Optional.empty();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * キャッシュを強制的にクリア
     */
    public void clearCache() {
        lock.writeLock().lock();
        try {
            cachedResult = null;
            lastValidationTime = null;
            logger.info("ライセンス検証キャッシュをクリアしました");
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * ライセンスを再読み込み
     */
    public void reload() {
        logger.info("ライセンスを再読み込みしています...");
        lock.writeLock().lock();
        try {
            loadLicense();
            validateAndCache();
            logger.info("ライセンスの再読み込みが完了しました");
        } catch (Exception e) {
            logger.error("ライセンスの再読み込みに失敗しました", e);
            cachedResult = new ValidationResult(false, "ライセンスの再読み込みに失敗しました: " + e.getMessage());
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * 定期的にライセンスを再検証（5分ごと）
     */
    @Scheduled(fixedRate = 300000) // 5分 = 300,000ミリ秒
    public void scheduledValidation() {
        logger.debug("定期的なライセンス検証を実行しています...");
        validateAndCache();
    }
    
    /**
     * キャッシュ統計情報を取得
     */
    public CacheStats getCacheStats() {
        lock.readLock().lock();
        try {
            return new CacheStats(
                cachedResult != null,
                isCacheValid(),
                lastValidationTime,
                cacheTTL
            );
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * キャッシュ統計情報を保持するクラス
     */
    public static class CacheStats {
        private final boolean cached;
        private final boolean valid;
        private final Instant lastValidation;
        private final Duration ttl;
        
        public CacheStats(boolean cached, boolean valid, Instant lastValidation, Duration ttl) {
            this.cached = cached;
            this.valid = valid;
            this.lastValidation = lastValidation;
            this.ttl = ttl;
        }
        
        public boolean isCached() {
            return cached;
        }
        
        public boolean isValid() {
            return valid;
        }
        
        public Instant getLastValidation() {
            return lastValidation;
        }
        
        public Duration getTtl() {
            return ttl;
        }
        
        @Override
        public String toString() {
            return String.format("CacheStats{cached=%s, valid=%s, lastValidation=%s, ttl=%s}",
                cached, valid, lastValidation, ttl);
        }
    }
}
```

#### 2. application.properties（スケジューリング有効化）

```properties
# スケジューリングを有効化
spring.task.scheduling.enabled=true

# スケジューリングのスレッドプール設定
spring.task.scheduling.pool.size=2
```

#### 3. Application.java（メインクラス）

```java
package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling // スケジューリングを有効化
public class Application {
    
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

#### 4. 使用例（コントローラー）

```java
package com.example.controller;

import com.example.service.CachedLicenseService;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/license")
public class LicenseController {
    
    private final CachedLicenseService licenseService;
    
    public LicenseController(CachedLicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    @GetMapping("/status")
    public Map<String, Object> getLicenseStatus() {
        Map<String, Object> status = new HashMap<>();
        status.put("valid", licenseService.isValid());
        
        var result = licenseService.getValidationResult();
        status.put("message", result.getMessage());
        status.put("timestamp", result.getTimestamp());
        
        return status;
    }
    
    @GetMapping("/cache-stats")
    public Map<String, Object> getCacheStats() {
        var stats = licenseService.getCacheStats();
        
        Map<String, Object> response = new HashMap<>();
        response.put("cached", stats.isCached());
        response.put("valid", stats.isValid());
        response.put("lastValidation", stats.getLastValidation());
        response.put("ttl", stats.getTtl().toString());
        
        return response;
    }
    
    @PostMapping("/clear-cache")
    public Map<String, String> clearCache() {
        licenseService.clearCache();
        Map<String, String> result = new HashMap<>();
        result.put("message", "キャッシュをクリアしました");
        return result;
    }
    
    @PostMapping("/reload")
    public Map<String, String> reloadLicense() {
        licenseService.reload();
        Map<String, String> result = new HashMap<>();
        result.put("message", "ライセンスを再読み込みしました");
        result.put("valid", String.valueOf(licenseService.isValid()));
        return result;
    }
}
```

#### 5. パフォーマンステスト例

```java
package com.example.performance;

import com.example.service.CachedLicenseService;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

/**
 * キャッシュのパフォーマンスをテスト
 */
@Component
public class PerformanceTest implements CommandLineRunner {
    
    private final CachedLicenseService licenseService;
    
    public PerformanceTest(CachedLicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    @Override
    public void run(String... args) throws Exception {
        // 初回検証（キャッシュなし）
        long start1 = System.nanoTime();
        boolean valid1 = licenseService.isValid();
        long end1 = System.nanoTime();
        System.out.println("初回検証: " + valid1 + " (" + (end1 - start1) / 1000000.0 + " ms)");
        
        // 2回目以降の検証（キャッシュあり）
        long totalTime = 0;
        int iterations = 1000;
        for (int i = 0; i < iterations; i++) {
            long start = System.nanoTime();
            licenseService.isValid();
            long end = System.nanoTime();
            totalTime += (end - start);
        }
        
        double avgTime = totalTime / (double) iterations / 1000000.0;
        System.out.println(iterations + "回の検証（キャッシュあり）: 平均 " + avgTime + " ms");
    }
}
```

### メリット

1. **優れたパフォーマンス**
   - 検証結果のキャッシュにより高速
   - 頻繁な検証でもオーバーヘッドが少ない
   - 大量のリクエストに対応可能

2. **動的更新対応**
   - ライセンスファイルの変更を自動検出
   - 再起動不要でライセンス更新
   - 有効期限の動的チェック

3. **柔軟な設定**
   - キャッシュTTLを調整可能
   - 検証頻度をカスタマイズ
   - セキュリティとパフォーマンスのバランス

4. **スレッドセーフ**
   - ReadWriteLockによる並行制御
   - マルチスレッド環境で安全
   - デッドロックのリスクが低い

5. **監視可能**
   - キャッシュ統計情報の取得
   - 検証履歴の追跡
   - パフォーマンスの可視化

### デメリット

1. **実装の複雑さ**
   - 最も複雑な実装
   - スレッドセーフティの考慮が必要
   - デバッグが難しい

2. **メモリ使用量**
   - キャッシュデータの保持
   - 複数のライセンスで増加
   - メモリリークのリスク

3. **タイミングの問題**
   - キャッシュTTL中は古い結果を返す
   - 無効なライセンスが一時的に有効と判定される可能性
   - セキュリティリスクの考慮が必要

4. **同期処理のオーバーヘッド**
   - ロックの取得/解放
   - 書き込み時のブロッキング
   - パフォーマンスへの影響

### 適用場面

- **高頻度のライセンスチェック**: APIリクエストごとの検証
- **長時間稼働サーバー**: 24/7稼働のアプリケーション
- **動的ライセンス更新**: ライセンスファイルが更新される環境
- **パフォーマンス重視**: レスポンスタイムが重要
- **大量トラフィック**: 多数の同時リクエスト

### 実装時の注意点

1. **適切なTTL設定**
   ```java
   // セキュリティとパフォーマンスのバランス
   private final Duration cacheTTL = Duration.ofMinutes(5); // 5分
   ```

2. **スレッドセーフティの確保**
   ```java
   // 読み取りは並行可能、書き込みは排他的
   private final ReadWriteLock lock = new ReentrantReadWriteLock();
   ```

3. **定期的な再検証**
   ```java
   @Scheduled(fixedRate = 300000) // 5分ごと
   public void scheduledValidation() {
       validateAndCache();
   }
   ```

4. **キャッシュのクリア機能**
   - 管理者が手動でクリア可能に
   - ライセンス更新時に自動クリア
   - エラー発生時のフォールバック

---

## パターン比較表

### 機能比較

| 機能 | シングルトン | Spring Boot | AOP | キャッシュ付き |
|------|------------|-------------|-----|--------------|
| **実装の複雑さ** | ★☆☆☆☆ | ★★☆☆☆ | ★★★★☆ | ★★★★★ |
| **パフォーマンス** | ★★★☆☆ | ★★★☆☆ | ★★☆☆☆ | ★★★★★ |
| **テスタビリティ** | ★☆☆☆☆ | ★★★★★ | ★★★★☆ | ★★★★☆ |
| **柔軟性** | ★☆☆☆☆ | ★★★★☆ | ★★★★★ | ★★★★☆ |
| **保守性** | ★★★☆☆ | ★★★★☆ | ★★★★★ | ★★★☆☆ |
| **学習コスト** | ★☆☆☆☆ | ★★☆☆☆ | ★★★★☆ | ★★★★☆ |
| **フレームワーク依存** | なし | Spring | Spring | Spring |
| **動的更新対応** | ✗ | △ | △ | ✓ |
| **関心の分離** | ✗ | ○ | ✓ | ○ |

### 特性比較

| 特性 | シングルトン | Spring Boot | AOP | キャッシュ付き |
|------|------------|-------------|-----|--------------|
| **初期化タイミング** | 初回アクセス時 | アプリ起動時 | アプリ起動時 | アプリ起動時 |
| **検証タイミング** | 初回のみ | 初回のみ | メソッド呼び出し時 | 定期的 |
| **キャッシュ** | なし | なし | なし | あり（TTL付き） |
| **スレッドセーフ** | 要実装 | Spring管理 | Spring管理 | 要実装 |
| **設定の外部化** | 難しい | 容易 | 容易 | 容易 |
| **エラーハンドリング** | 手動 | Spring統合 | アスペクトで統一 | 手動 |
| **ログ出力** | 手動 | SLF4J統合 | SLF4J統合 | SLF4J統合 |

### 適用規模

| プロジェクト規模 | 推奨パターン | 理由 |
|----------------|------------|------|
| **小規模（〜1万行）** | シングルトン | シンプルで十分 |
| **中規模（1〜10万行）** | Spring Boot統合 | DIとテストの恩恵 |
| **大規模（10万行〜）** | AOP + キャッシュ | 保守性とパフォーマンス |
| **マイクロサービス** | Spring Boot統合 | Spring Cloudとの統合 |
| **レガシーシステム** | AOP | 既存コードへの影響最小 |

### パフォーマンス比較（目安）

| パターン | 初回検証 | 2回目以降 | メモリ使用量 | CPU使用量 |
|---------|---------|----------|------------|----------|
| **シングルトン** | 10ms | 0.01ms | 低 | 低 |
| **Spring Boot** | 10ms | 0.01ms | 中 | 低 |
| **AOP** | 10ms | 0.1ms | 中 | 中 |
| **キャッシュ付き** | 10ms | 0.001ms | 中 | 低 |

※ 実際のパフォーマンスは環境やライセンスファイルのサイズに依存します

---

## 選択ガイドライン

### プロジェクトの規模で選ぶ

#### 小規模プロジェクト（〜1万行）
**推奨: シングルトンライセンスマネージャー**

理由:
- 実装がシンプルで理解しやすい
- オーバーヘッドが最小限
- 依存関係が少ない
- 迅速な開発が可能

適用例:
- デスクトップアプリケーション
- CLIツール
- 小規模なWebアプリ

#### 中規模プロジェクト（1〜10万行）
**推奨: Spring Boot統合**

理由:
- DIによる依存関係の管理
- テストの自動化が容易
- 設定の外部化
- Springエコシステムの活用

適用例:
- 企業向けWebアプリケーション
- REST APIサーバー
- バックオフィスシステム

#### 大規模プロジェクト（10万行〜）
**推奨: AOP + キャッシュ付き検証**

理由:
- 関心の分離による保守性
- パフォーマンスの最適化
- 柔軟な制御
- 一元的な管理

適用例:
- エンタープライズアプリケーション
- マイクロサービスアーキテクチャ
- 高トラフィックのWebサービス

### 技術スタックで選ぶ

#### Spring Boot使用
**推奨: Spring Boot統合 または AOP**

メリット:
- Springの機能を最大限活用
- 既存のSpring設定に統合
- Spring Securityとの連携

#### フレームワーク未使用
**推奨: シングルトン または キャッシュ付き**

メリット:
- 外部依存が少ない
- シンプルな実装
- 軽量

### 要件で選ぶ

#### シンプルさ重視
**推奨: シングルトンライセンスマネージャー**

特徴:
- 最小限のコード
- 理解しやすい
- 迅速な実装

#### テスタビリティ重視
**推奨: Spring Boot統合**

特徴:
- モックへの置き換えが容易
- 単体テストが書きやすい
- 統合テストのサポート

#### 関心の分離重視
**推奨: アスペクト指向プログラミング（AOP）**

特徴:
- ビジネスロジックとライセンス検証を分離
- 宣言的な制御
- 既存コードへの影響最小

#### パフォーマンス重視
**推奨: キャッシュ付きライセンス検証**

特徴:
- 検証結果のキャッシュ
- 高頻度の検証に対応
- 最小限のオーバーヘッド

### ユースケース別の推奨

#### ケース1: スタートアップのMVP開発
**推奨: シングルトン**

理由:
- 迅速な開発が最優先
- 機能の検証が目的
- 後で変更可能

#### ケース2: エンタープライズ向けSaaS
**推奨: Spring Boot統合 + AOP**

理由:
- 複数の顧客に対応
- 細かいライセンス制御が必要
- 保守性が重要

#### ケース3: 高トラフィックのAPI
**推奨: キャッシュ付き検証**

理由:
- パフォーマンスが最優先
- 大量のリクエストに対応
- レスポンスタイムの最小化

#### ケース4: レガシーシステムへの追加
**推奨: AOP**

理由:
- 既存コードへの影響を最小化
- 段階的な導入が可能
- ビジネスロジックの変更不要

---

## パターンの組み合わせ

複数のパターンを組み合わせることで、それぞれのメリットを活かすことができます。

### 組み合わせ1: Spring Boot + キャッシュ

**実装方法:**
```java
@Service
public class CachedLicenseService {
    // Spring Bootの依存性注入
    private final LicenseProperties properties;
    
    // キャッシュ機能
    private ValidationResult cachedResult;
    private Instant lastValidationTime;
    
    // コンストラクタインジェクション
    public CachedLicenseService(LicenseProperties properties) {
        this.properties = properties;
    }
    
    // 残りの実装...
}
```

**メリット:**
- Spring BootのDIとキャッシュの両方の恩恵
- 設定の外部化とパフォーマンスの最適化
- テスタビリティとパフォーマンスの両立

**適用場面:**
- 中〜大規模のSpring Bootアプリケーション
- 高トラフィックのWebサービス

### 組み合わせ2: AOP + キャッシュ

**実装方法:**
```java
@Aspect
@Component
public class LicenseAspect {
    // キャッシュ付きライセンスサービスを注入
    private final CachedLicenseService licenseService;
    
    public LicenseAspect(CachedLicenseService licenseService) {
        this.licenseService = licenseService;
    }
    
    @Around("@annotation(RequiresLicense)")
    public Object checkLicense(ProceedingJoinPoint joinPoint) throws Throwable {
        // キャッシュされた検証結果を使用
        if (!licenseService.isValid()) {
            throw new LicenseValidationException("無効なライセンスです");
        }
        return joinPoint.proceed();
    }
}
```

**メリット:**
- 関心の分離とパフォーマンスの最適化
- 宣言的な制御と高速な検証
- 大規模アプリケーションに最適

**適用場面:**
- エンタープライズアプリケーション
- 複雑なビジネスロジックを持つシステム

### 組み合わせ3: Spring Boot + AOP + キャッシュ

**完全な統合例:**

これは最も包括的な組み合わせで、すべてのメリットを活かすことができます。

**構成:**
1. Spring Bootによる依存性注入と設定管理
2. キャッシュ付きライセンスサービスでパフォーマンス最適化
3. AOPによる宣言的なライセンス制御

**メリット:**
- 最高レベルの柔軟性
- 優れたパフォーマンス
- 保守性の高いコード
- テストの容易さ

**デメリット:**
- 実装が最も複雑
- 学習コストが高い
- 小規模プロジェクトには過剰

**適用場面:**
- 大規模エンタープライズアプリケーション
- ミッションクリティカルなシステム
- 長期的な保守が必要なプロジェクト

---

## 実装時の注意点

### 1. セキュリティ

#### 公開鍵の管理
```java
// 良い例: 公開鍵をソースコードに埋め込む
private static final String PUBLIC_KEY_BASE64 = 
    "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...";

// 悪い例: 公開鍵を外部ファイルから読み込む（改ざんのリスク）
// String publicKey = readFromFile("public.key");
```

#### ログ出力時の注意
```java
// 良い例: ライセンスの詳細をログに出力しない
logger.info("ライセンス検証が完了しました");

// 悪い例: ライセンスの内容をログに出力（情報漏洩のリスク）
// logger.info("ライセンス内容: {}", license.toString());
```

### 2. パフォーマンス

#### 検証頻度の最適化
```java
// 良い例: 起動時に1回だけ検証
@PostConstruct
public void initialize() {
    validateLicense();
}

// 悪い例: リクエストごとに毎回検証（パフォーマンス低下）
// public void handleRequest() {
//     validateLicense(); // 毎回実行は避ける
// }
```

#### キャッシュの活用
```java
// 良い例: 検証結果をキャッシュ
private Boolean isValid = null;

public boolean isLicenseValid() {
    if (isValid != null) {
        return isValid;
    }
    isValid = performValidation();
    return isValid;
}
```

### 3. エラーハンドリング

#### 適切な例外処理
```java
// 良い例: 詳細なエラー情報を提供
try {
    validateLicense();
} catch (IOException e) {
    logger.error("ライセンスファイルの読み込みに失敗しました", e);
    throw new LicenseValidationException("ライセンスファイルが見つかりません", e);
} catch (Exception e) {
    logger.error("ライセンス検証中にエラーが発生しました", e);
    throw new LicenseValidationException("ライセンス検証に失敗しました", e);
}
```

#### グレースフルデグラデーション
```java
// 開発環境ではライセンスチェックをスキップ
if (isDevelopmentMode()) {
    logger.warn("開発モードのため、ライセンスチェックをスキップします");
    return true;
}
```

### 4. テスト

#### モックの使用
```java
@Test
public void testWithValidLicense() {
    // モックライセンスサービスを作成
    LicenseService mockService = Mockito.mock(LicenseService.class);
    Mockito.when(mockService.isValid()).thenReturn(true);
    
    // テスト実行
    MyService service = new MyService(mockService);
    assertTrue(service.canExecute());
}
```

#### テスト用ライセンスの準備
```java
// テスト用の設定ファイル
// src/test/resources/application-test.properties
license.file.path=src/test/resources/test-license.bin
license.validation.enabled=true
```

### 5. ドキュメント

#### コードコメント
```java
/**
 * ライセンスを検証します。
 * 
 * このメソッドは以下のチェックを行います：
 * 1. ライセンスファイルの存在確認
 * 2. 署名の検証
 * 3. 有効期限のチェック
 * 
 * @return ライセンスが有効な場合はtrue
 * @throws LicenseValidationException ライセンスが無効な場合
 */
public boolean validateLicense() {
    // 実装...
}
```

#### README.mdの作成
プロジェクトのルートに、ライセンス機能の使用方法を記載したREADME.mdを作成することを推奨します。

---

## まとめ

### 各パターンの推奨度

| パターン | 小規模 | 中規模 | 大規模 | 総合評価 |
|---------|-------|-------|-------|---------|
| **シングルトン** | ★★★★★ | ★★☆☆☆ | ★☆☆☆☆ | 初心者向け |
| **Spring Boot** | ★★☆☆☆ | ★★★★★ | ★★★★☆ | 汎用的 |
| **AOP** | ★☆☆☆☆ | ★★★☆☆ | ★★★★★ | 上級者向け |
| **キャッシュ付き** | ★☆☆☆☆ | ★★★★☆ | ★★★★★ | 高性能 |

### 最終的な選択基準

1. **プロジェクトの規模と複雑さ**を最優先に考慮
2. **使用している技術スタック**（Spring Bootの有無）
3. **パフォーマンス要件**（検証頻度、レスポンスタイム）
4. **開発チームのスキルレベル**
5. **保守性と拡張性**の要件

### 実装のステップ

1. **要件の明確化**: どのパターンが適切か判断
2. **プロトタイプの作成**: 小規模な実装で検証
3. **テストの作成**: 単体テストと統合テスト
4. **本番環境への適用**: 段階的なロールアウト
5. **監視と最適化**: パフォーマンスの測定と改善

このガイドが、License3jの実装パターン選択の参考になれば幸いです。プロジェクトの要件に最適なパターンを選択し、効果的なライセンス管理を実現してください。
